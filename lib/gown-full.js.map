{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/index-full","external/pixi-layout/src/index.js","external/pixi-layout/src/layout/HorizontalLayout.js","external/pixi-layout/src/layout/Layout.js","external/pixi-layout/src/layout/LayoutAlignment.js","external/pixi-layout/src/layout/TiledColumnsLayout.js","external/pixi-layout/src/layout/TiledLayout.js","external/pixi-layout/src/layout/TiledRowsLayout.js","external/pixi-layout/src/layout/VerticalLayout.js","external/pixi-shapes/src/index.js","external/pixi-shapes/src/shapes/Diamond.js","external/pixi-shapes/src/shapes/Ellipse.js","external/pixi-shapes/src/shapes/Line.js","external/pixi-shapes/src/shapes/Rect.js","external/pixi-shapes/src/shapes/Shape.js","node_modules/eventemitter3/index.js","src/controls/Application.js","src/controls/Button.js","src/controls/Check.js","src/controls/InputControl.js","src/controls/LayoutGroup.js","src/controls/List.js","src/controls/PickerList.js","src/controls/ScrollBar.js","src/controls/ScrollContainer.js","src/controls/ScrollText.js","src/controls/ScrollThumb.js","src/controls/Scrollable.js","src/controls/Scroller.js","src/controls/Slider.js","src/controls/TextInput.js","src/controls/ToggleButton.js","src/controls/renderers/DefaultListItemRenderer.js","src/core/Control.js","src/core/Skinable.js","src/core/index.js","src/data/ListCollection.js","src/skin/Theme.js","src/skin/ThemeFont.js","src/skin/ThemeParser.js","src/utils/InputWrapper.js","src/utils/ScaleContainer.js","src/utils/SliderData.js","src/utils/index.js","src/utils/mixin.js","src/utils/mouseWheelSupport.js","src/utils/position.js","src/utils/resizeScaling.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"gown-full.js","sourceRoot":"./","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","(function (global){\n// full version of gown \r\n// (includes pixi-layout and pixi-shape, so you only need to add pixi.js \r\n//  and gown.js into your html file)\r\nif (typeof PIXI === 'undefined') {\r\n    if (window.console) {\r\n        window.console.warn('pixi.js has to be loaded before loading gown.js');\r\n    }\r\n} else {\r\n    PIXI.shapes = require('../external/pixi-shapes/src');\r\n    PIXI.layout = require('../external/pixi-layout/src');\r\n\r\n    var core = module.exports = require('./core');\r\n\r\n    // controls\r\n    core.Application =            require('./controls/Application');\r\n    core.Button =                 require('./controls/Button');\r\n    core.Check =                  require('./controls/Check');\r\n    core.InputControl =           require('./controls/InputControl');\r\n    core.LayoutGroup =            require('./controls/LayoutGroup');\r\n    core.List =                   require('./controls/List');\r\n    core.PickerList =             require('./controls/PickerList');\r\n    core.Scrollable =             require('./controls/Scrollable');\r\n    core.ScrollBar =              require('./controls/ScrollBar');\r\n    core.ScrollContainer =        require('./controls/ScrollContainer');\r\n    core.Scroller =               require('./controls/Scroller');\r\n    core.ScrollText =             require('./controls/ScrollText');\r\n    core.ScrollThumb =            require('./controls/ScrollThumb');\r\n    core.Slider =                 require('./controls/Slider');\r\n    core.TextInput =              require('./controls/TextInput');\r\n    core.ToggleButton =           require('./controls/ToggleButton');\r\n\r\n    // data\r\n    core.ListCollection =         require('./data/ListCollection');\r\n\r\n    // control renderer\r\n    core.DefaultListItemRenderer =  require('./controls/renderers/DefaultListItemRenderer');\r\n\r\n    // skin\r\n    core.Theme =           require('./skin/Theme');\r\n    core.ThemeFont =       require('./skin/ThemeFont');\r\n    core.ThemeParser =     require('./skin/ThemeParser');\r\n\r\n    // add core plugins.\r\n    core.utils          = require('./utils');\r\n\r\n    // use default pixi loader\r\n    core.loader = PIXI.loader;\r\n\r\n    // mixin the deprecation features.\r\n    //Object.assign(core; require('./deprecation'));\r\n\r\n    // export GOWN globally.\r\n    global.GOWN = core;\r\n}\r\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9pbmRleC1mdWxsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZnVsbCB2ZXJzaW9uIG9mIGdvd24gXHJcbi8vIChpbmNsdWRlcyBwaXhpLWxheW91dCBhbmQgcGl4aS1zaGFwZSwgc28geW91IG9ubHkgbmVlZCB0byBhZGQgcGl4aS5qcyBcclxuLy8gIGFuZCBnb3duLmpzIGludG8geW91ciBodG1sIGZpbGUpXHJcbmlmICh0eXBlb2YgUElYSSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIGlmICh3aW5kb3cuY29uc29sZSkge1xyXG4gICAgICAgIHdpbmRvdy5jb25zb2xlLndhcm4oJ3BpeGkuanMgaGFzIHRvIGJlIGxvYWRlZCBiZWZvcmUgbG9hZGluZyBnb3duLmpzJyk7XHJcbiAgICB9XHJcbn0gZWxzZSB7XHJcbiAgICBQSVhJLnNoYXBlcyA9IHJlcXVpcmUoJy4uL2V4dGVybmFsL3BpeGktc2hhcGVzL3NyYycpO1xyXG4gICAgUElYSS5sYXlvdXQgPSByZXF1aXJlKCcuLi9leHRlcm5hbC9waXhpLWxheW91dC9zcmMnKTtcclxuXHJcbiAgICB2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb3JlJyk7XHJcblxyXG4gICAgLy8gY29udHJvbHNcclxuICAgIGNvcmUuQXBwbGljYXRpb24gPSAgICAgICAgICAgIHJlcXVpcmUoJy4vY29udHJvbHMvQXBwbGljYXRpb24nKTtcclxuICAgIGNvcmUuQnV0dG9uID0gICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29udHJvbHMvQnV0dG9uJyk7XHJcbiAgICBjb3JlLkNoZWNrID0gICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2NvbnRyb2xzL0NoZWNrJyk7XHJcbiAgICBjb3JlLklucHV0Q29udHJvbCA9ICAgICAgICAgICByZXF1aXJlKCcuL2NvbnRyb2xzL0lucHV0Q29udHJvbCcpO1xyXG4gICAgY29yZS5MYXlvdXRHcm91cCA9ICAgICAgICAgICAgcmVxdWlyZSgnLi9jb250cm9scy9MYXlvdXRHcm91cCcpO1xyXG4gICAgY29yZS5MaXN0ID0gICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb250cm9scy9MaXN0Jyk7XHJcbiAgICBjb3JlLlBpY2tlckxpc3QgPSAgICAgICAgICAgICByZXF1aXJlKCcuL2NvbnRyb2xzL1BpY2tlckxpc3QnKTtcclxuICAgIGNvcmUuU2Nyb2xsYWJsZSA9ICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29udHJvbHMvU2Nyb2xsYWJsZScpO1xyXG4gICAgY29yZS5TY3JvbGxCYXIgPSAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb250cm9scy9TY3JvbGxCYXInKTtcclxuICAgIGNvcmUuU2Nyb2xsQ29udGFpbmVyID0gICAgICAgIHJlcXVpcmUoJy4vY29udHJvbHMvU2Nyb2xsQ29udGFpbmVyJyk7XHJcbiAgICBjb3JlLlNjcm9sbGVyID0gICAgICAgICAgICAgICByZXF1aXJlKCcuL2NvbnRyb2xzL1Njcm9sbGVyJyk7XHJcbiAgICBjb3JlLlNjcm9sbFRleHQgPSAgICAgICAgICAgICByZXF1aXJlKCcuL2NvbnRyb2xzL1Njcm9sbFRleHQnKTtcclxuICAgIGNvcmUuU2Nyb2xsVGh1bWIgPSAgICAgICAgICAgIHJlcXVpcmUoJy4vY29udHJvbHMvU2Nyb2xsVGh1bWInKTtcclxuICAgIGNvcmUuU2xpZGVyID0gICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29udHJvbHMvU2xpZGVyJyk7XHJcbiAgICBjb3JlLlRleHRJbnB1dCA9ICAgICAgICAgICAgICByZXF1aXJlKCcuL2NvbnRyb2xzL1RleHRJbnB1dCcpO1xyXG4gICAgY29yZS5Ub2dnbGVCdXR0b24gPSAgICAgICAgICAgcmVxdWlyZSgnLi9jb250cm9scy9Ub2dnbGVCdXR0b24nKTtcclxuXHJcbiAgICAvLyBkYXRhXHJcbiAgICBjb3JlLkxpc3RDb2xsZWN0aW9uID0gICAgICAgICByZXF1aXJlKCcuL2RhdGEvTGlzdENvbGxlY3Rpb24nKTtcclxuXHJcbiAgICAvLyBjb250cm9sIHJlbmRlcmVyXHJcbiAgICBjb3JlLkRlZmF1bHRMaXN0SXRlbVJlbmRlcmVyID0gIHJlcXVpcmUoJy4vY29udHJvbHMvcmVuZGVyZXJzL0RlZmF1bHRMaXN0SXRlbVJlbmRlcmVyJyk7XHJcblxyXG4gICAgLy8gc2tpblxyXG4gICAgY29yZS5UaGVtZSA9ICAgICAgICAgICByZXF1aXJlKCcuL3NraW4vVGhlbWUnKTtcclxuICAgIGNvcmUuVGhlbWVGb250ID0gICAgICAgcmVxdWlyZSgnLi9za2luL1RoZW1lRm9udCcpO1xyXG4gICAgY29yZS5UaGVtZVBhcnNlciA9ICAgICByZXF1aXJlKCcuL3NraW4vVGhlbWVQYXJzZXInKTtcclxuXHJcbiAgICAvLyBhZGQgY29yZSBwbHVnaW5zLlxyXG4gICAgY29yZS51dGlscyAgICAgICAgICA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcclxuXHJcbiAgICAvLyB1c2UgZGVmYXVsdCBwaXhpIGxvYWRlclxyXG4gICAgY29yZS5sb2FkZXIgPSBQSVhJLmxvYWRlcjtcclxuXHJcbiAgICAvLyBtaXhpbiB0aGUgZGVwcmVjYXRpb24gZmVhdHVyZXMuXHJcbiAgICAvL09iamVjdC5hc3NpZ24oY29yZTsgcmVxdWlyZSgnLi9kZXByZWNhdGlvbicpKTtcclxuXHJcbiAgICAvLyBleHBvcnQgR09XTiBnbG9iYWxseS5cclxuICAgIGdsb2JhbC5HT1dOID0gY29yZTtcclxufVxyXG4iXX0=","module.exports = PIXI.layout = {\r\n    HorizontalLayout:     require('./layout/HorizontalLayout'),\r\n    Layout:               require('./layout/Layout'),\r\n    LayoutAlignment:      require('./layout/LayoutAlignment'),\r\n    TiledColumnsLayout:   require('./layout/TiledColumnsLayout'),\r\n    TiledLayout:          require('./layout/TiledLayout'),\r\n    TiledRowsLayout:      require('./layout/TiledRowsLayout'),\r\n    VerticalLayout:       require('./layout/VerticalLayout')\r\n};\r\n","var LayoutAlignment = require('./LayoutAlignment');\r\n\r\n/**\r\n * HorizontalLayout - just set alignment to\r\n * LayoutAlignment.HORIZONTAL_ALIGNMENT\r\n *\r\n * @class HorizontalLayout\r\n * @extends PIXI.layout.LayoutAlignment\r\n * @memberof PIXI.layout\r\n * @constructor\r\n */\r\nfunction HorizontalLayout() {\r\n    LayoutAlignment.call(this);\r\n    this.alignment = LayoutAlignment.HORIZONTAL_ALIGNMENT;\r\n}\r\n\r\nHorizontalLayout.prototype = Object.create( LayoutAlignment.prototype );\r\nHorizontalLayout.prototype.constructor = HorizontalLayout;\r\nmodule.exports = HorizontalLayout;\r\n","/**\r\n * basic layout stub - see LayoutAlignment\r\n *\r\n * @class Layout\r\n * @memberof PIXI.layout\r\n * @constructor\r\n */\r\nfunction Layout() {\r\n    this.gap = 0;\r\n    this.padding = 0;\r\n}\r\n\r\nmodule.exports = Layout;\r\n\r\n/**\r\n * If the total item height is smaller than the height of the bounds,\r\n * the items will be aligned to the top.\r\n *\r\n * @property VERTICAL_ALIGN_TOP\r\n * @static\r\n */\r\nLayout.VERTICAL_ALIGN_TOP = 'top';\r\n\r\n/**\r\n * If the total item height is smaller than the height of the bounds,\r\n * the items will be aligned to the middle.\r\n *\r\n * @property VERTICAL_ALIGN_MIDDLE\r\n * @static\r\n */\r\nLayout.VERTICAL_ALIGN_MIDDLE = 'middle';\r\n\r\n/**\r\n * Alignment justified\r\n *\r\n * @property ALIGN_JUSTIFY\r\n * @static\r\n */\r\nLayout.ALIGN_JUSTIFY = 'justify';\r\n\r\n/**\r\n * If the total item height is smaller than the height of the bounds,\r\n * the items will be aligned to the bottom.\r\n *\r\n * @property VERTICAL_ALIGN_BOTTOM\r\n * @static\r\n */\r\nLayout.VERTICAL_ALIGN_BOTTOM = 'bottom';\r\n\r\n/**\r\n * If the total item width is smaller than the width of the bounds, the\r\n * items will be aligned to the left.\r\n *\r\n * @property HORIZONTAL_ALIGN_LEFT\r\n * @static\r\n */\r\nLayout.HORIZONTAL_ALIGN_LEFT = 'left';\r\n\r\n/**\r\n * If the total item width is smaller than the width of the bounds, the\r\n * items will be aligned to the center.\r\n *\r\n * @property HORIZONTAL_ALIGN_CENTER\r\n * @static\r\n */\r\nLayout.HORIZONTAL_ALIGN_CENTER = 'center';\r\n\r\n/**\r\n * If the total item width is smaller than the width of the bounds, the\r\n * items will be aligned to the right.\r\n *\r\n * @property HORIZONTAL_ALIGN_RIGHT\r\n * @static\r\n */\r\nLayout.HORIZONTAL_ALIGN_RIGHT = 'right';\r\n\r\n\r\n\r\n/**\r\n * The space, in pixels, between items.\r\n *\r\n * @property gap\r\n * @type Number\r\n */\r\nObject.defineProperty(Layout.prototype, 'gap', {\r\n    get: function() {\r\n        return this._gap;\r\n    },\r\n    set: function(value) {\r\n        if(this._gap === value) {\r\n            return;\r\n        }\r\n        this._gap = value;\r\n        this._needUpdate = true;\r\n    }\r\n});\r\n\r\n/**\r\n * Indicates if the layout needs to be rearranged.\r\n *\r\n * @property needUpdate\r\n * @readonly\r\n */\r\nObject.defineProperty(Layout.prototype, 'needUpdate', {\r\n    get: function() {\r\n        return this._needUpdate;\r\n    }\r\n});\r\n\r\n/**\r\n * shotrtcut to set all paddings (left, right, top, bottom)\r\n *\r\n * @property padding\r\n * @type Number\r\n */\r\nObject.defineProperty(Layout.prototype, 'padding', {\r\n    set: function(value) {\r\n        this._paddingLeft = value;\r\n        this._paddingRight = value;\r\n        this._paddingBottom = value;\r\n        this._paddingTop = value;\r\n        this._needUpdate = true;\r\n    },\r\n    get: function (){\r\n        // just return paddingTop, because we do not save the\r\n        // overall padding value (just like feathers)\r\n        return this._paddingTop;\r\n    }\r\n});\r\n\r\n/**\r\n * The minimum space, in pixels, above the items.\r\n *\r\n * @default 0\r\n * @property paddingTop\r\n * @type Number\r\n */\r\nObject.defineProperty(Layout.prototype, 'paddingTop', {\r\n    get:  function() {\r\n        return this._paddingTop;\r\n    },\r\n    set: function(value) {\r\n        if(this._paddingTop === value) {\r\n            return;\r\n        }\r\n        this._paddingTop = value;\r\n        this._needUpdate = true;\r\n    }\r\n});\r\n\r\n/**\r\n * The minimum space, in pixels, below the items.\r\n *\r\n * @default 0\r\n * @property paddingTop\r\n * @type Number\r\n */\r\nObject.defineProperty(Layout.prototype, 'paddingBottom', {\r\n    get:  function() {\r\n        return this._paddingBottom;\r\n    },\r\n    set: function(value) {\r\n        if(this._paddingBottom === value) {\r\n            return;\r\n        }\r\n        this._paddingBottom = value;\r\n        this._needUpdate = true;\r\n    }\r\n});\r\n\r\n/**\r\n * The space, in pixels, that appears to the left, before the first\r\n * item.\r\n *\r\n * @default 0\r\n * @property paddingLeft\r\n * @type Number\r\n */\r\nObject.defineProperty(Layout.prototype, 'paddingLeft', {\r\n    get:  function() {\r\n        return this._paddingLeft;\r\n    },\r\n    set: function(value) {\r\n        if(this._paddingLeft === value) {\r\n            return;\r\n        }\r\n        this._paddingLeft = value;\r\n        this._needUpdate = true;\r\n    }\r\n});\r\n\r\n/**\r\n * The space, in pixels, that appears to the right, after the last item.\r\n *\r\n * @default 0\r\n * @property paddingLeft\r\n * @type Number\r\n */\r\nObject.defineProperty(Layout.prototype, 'paddingRight', {\r\n    get:  function() {\r\n        return this._paddingRight;\r\n    },\r\n    set: function(value) {\r\n        if(this._paddingRight === value) {\r\n            return;\r\n        }\r\n        this._paddingRight = value;\r\n        this._needUpdate = true;\r\n    }\r\n});\r\n\r\n/**\r\n * Position (and possibly resizes) the supplied items.\r\n *\r\n * @method layout\r\n * @param items items that will be layouted {Array}\r\n * @param viewPortBounds {ViewPortBounds}\r\n */\r\n/* jshint unused: false */\r\nLayout.prototype.layout = function (items, viewPortBounds) {\r\n};\r\n","var Layout = require('./Layout');\r\n\r\n/**\r\n * basic layout\r\n *\r\n * @class LayoutAlignment\r\n * @extends PIXI.layout.Layout\r\n * @memberof PIXI.layout\r\n * @constructor\r\n */\r\nfunction LayoutAlignment() {\r\n    Layout.call(this);\r\n}\r\n\r\nLayoutAlignment.prototype = Object.create( Layout.prototype );\r\nLayoutAlignment.prototype.constructor = LayoutAlignment;\r\nmodule.exports = LayoutAlignment;\r\n\r\nLayoutAlignment.VERTICAL_ALIGNMENT = 'vertical';\r\nLayoutAlignment.HORIZONTAL_ALIGNMENT = 'horizontal';\r\n\r\n/**\r\n * apply percentage width/height to items.\r\n * percentages have higher priorities than fixed with.\r\n * So if you set a width higher than 0 but also percentWidth,\r\n * the width will be recalculated according to percentWidth.\r\n *\r\n * @method applyPercent\r\n * @param items\r\n * @param explicit space we have for the components\r\n * (this function will handle padding and gap, so the explicitWidth is\r\n *  for the whole available width)\r\n */\r\nLayoutAlignment.prototype.applyPercent = function(items, explicit) {\r\n    var _hor = (this.alignment === LayoutAlignment.HORIZONTAL_ALIGNMENT);\r\n\r\n    var itemCount = items.length;\r\n    var remaining = explicit;\r\n    var totalExplicit = 0;\r\n    var totalPercent = 0;\r\n\r\n    var i, itemPercent, item;\r\n    // sum up width/height required for all items\r\n    for (i = 0; i < itemCount; i++) {\r\n        item = items[i];\r\n        var itemSpace;\r\n        itemPercent = _hor ? item.percentWidth : item.percentHeight;\r\n        itemSpace = _hor ? item.width : item.height;\r\n\r\n        if (!isNaN(itemPercent) && itemPercent !== undefined &&\r\n            itemPercent !== null) {\r\n            totalPercent += itemPercent;\r\n        } else if (!isNaN(itemSpace)) {\r\n            // no percentWidth/percentHeight set for this item\r\n            totalExplicit += itemSpace;\r\n        }\r\n    }\r\n\r\n    // add space for all gaps\r\n    totalExplicit += this._firstGap > 0 ? this._firstGap : this._gap;\r\n    totalExplicit += (this._gap * (itemCount - 3));\r\n    totalExplicit += this._lastGap > 0 ? this._lastGap : this._gap;\r\n\r\n    var padding = _hor ?\r\n        this._paddingLeft + this._paddingRight :\r\n        this._paddingTop + this._paddingBottom;\r\n    totalExplicit += padding;\r\n\r\n    // use whole available space - if we do not sum up to 100 we will\r\n    // stretch the items\r\n    if(totalPercent < 100) {\r\n        totalPercent = 100;\r\n    }\r\n\r\n    remaining -= totalExplicit;\r\n    var percentToPixels = remaining / totalPercent;\r\n    // claculate width/height for each item based on remaining width/height\r\n    for(i = 0; i < itemCount; i++) {\r\n        item = items[i];\r\n        itemPercent = _hor ? item.percentWidth : item.percentHeight;\r\n        if (itemPercent > 0) {\r\n            if (_hor) {\r\n                item.width = percentToPixels * itemPercent;\r\n            } else {\r\n                item.height = percentToPixels * itemPercent;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * get current gap (includes first and last gap)\r\n *\r\n * @method _currentGap\r\n * @private\r\n * @param i current item position\r\n * @param items list of items (to determine if we are at the last gap)\r\n */\r\nLayoutAlignment.prototype._currentGap = function(i, items) {\r\n    if(!isNaN(this._firstGap) && i === 0)\r\n    {\r\n        return this._firstGap;\r\n    }\r\n    else if(!isNaN(this._lastGap) && i > 0 && i === items.length - 2)\r\n    {\r\n        return this._lastGap;\r\n    }\r\n    return this._gap;\r\n};\r\n\r\n/**\r\n * calculate layout for container\r\n */\r\nLayoutAlignment.prototype.layoutContainer = function(container) {\r\n    var _hor = (this.alignment === LayoutAlignment.HORIZONTAL_ALIGNMENT);\r\n    return this.layout(container.children, \r\n        _hor ? container.width : container.height);\r\n};\r\n\r\n/**\r\n * Position (and possibly resizes) the supplied items.\r\n *\r\n * @method layout\r\n * @param items items that will be layouted {Array}\r\n * @param maxSpace max. width/height for the items {Number}\r\n */\r\nLayoutAlignment.prototype.layout = function(items, maxSpace) {\r\n    var _hor = (this.alignment === LayoutAlignment.HORIZONTAL_ALIGNMENT);\r\n\r\n    maxSpace = maxSpace || NaN;\r\n    // width/height the current layout takes\r\n    var width = 0;\r\n    var height = 0;\r\n    var paddingStart = _hor ? this._paddingLeft : this._paddingTop;\r\n\r\n    // recalculate width/height for items with percentages\r\n    this.applyPercent(items, maxSpace);\r\n\r\n    var position = paddingStart;\r\n\r\n    // calculate item position (x/y coordinates)\r\n    for(var i = 0; i < items.length; i++)\r\n    {\r\n        var item = items[i];\r\n\r\n        // move item to position calculated in previous loop\r\n        if (_hor) {\r\n            item.x = Math.floor(position);\r\n            // return height of highest item\r\n            height = Math.max(item.height, height);\r\n        } else {\r\n            item.y = Math.floor(position);\r\n            // return width of widest item\r\n            width = Math.max(item.width, width);\r\n        }\r\n        var itemSpace = _hor ? item.width : item.height;\r\n        // calculate position for next item\r\n        position += itemSpace + this._currentGap(i, items);\r\n    }\r\n    if (_hor) {\r\n        width = position;\r\n    } else {\r\n        height = position;\r\n    }\r\n    return [width, height];\r\n};\r\n\r\n/**\r\n * The space between the first and second element\r\n *\r\n * @property firstGap\r\n * @type String\r\n */\r\nObject.defineProperty(LayoutAlignment.prototype, 'firstGap', {\r\n    set: function(value) {\r\n        if (value === this._firstGap) {\r\n            return;\r\n        }\r\n        this._firstGap = value;\r\n        this._needUpdate = true;\r\n    },\r\n    get: function() {\r\n        return this._firstGap;\r\n    }\r\n});\r\n\r\n/**\r\n * The space between the last and second-to-last element\r\n *\r\n * @property firstGap\r\n * @type String\r\n */\r\nObject.defineProperty(LayoutAlignment.prototype, 'lastGap', {\r\n    set: function(value) {\r\n        if (value === this._lastGap) {\r\n            return;\r\n        }\r\n        this._lastGap = value;\r\n        this._needUpdate = true;\r\n    },\r\n    get: function() {\r\n        return this._lastGap;\r\n    }\r\n});\r\n","var TiledLayout = require('./TiledLayout');\r\n\r\n/**\r\n * Tiled columns Layout\r\n * (roughly based on starling TiledColumnsLayout)\r\n *\r\n * @class TiledColumnsLayout\r\n * @extends PIXI.layout.TiledLayout\r\n * @memberof PIXI.layout\r\n * @constructor\r\n */\r\n\r\nfunction TiledColumnsLayout() {\r\n    TiledLayout.call(this);\r\n    this._paging = TiledLayout.PAGING_VERTICAL;\r\n    this._orientation = TiledLayout.ORIENTATION_COLUMNS;\r\n}\r\n\r\nTiledColumnsLayout.prototype = Object.create( TiledLayout.prototype );\r\nTiledColumnsLayout.prototype.constructor = TiledColumnsLayout;\r\nmodule.exports = TiledColumnsLayout;\r\n\r\n/**\r\n * Quickly sets both <code>horizontalGap</code> and <code>verticalGap</code>\r\n * to the same value. The <code>gap</code> getter always returns the\r\n * value of <code>verticalGap</code>, but the value of\r\n * <code>horizontalGap</code> may be different.\r\n *\r\n * @default 0\r\n *\r\n * @see #_horizontalGap\r\n * @see #_verticalGap\r\n * @property gap\r\n * @type Number\r\n */\r\nObject.defineProperty(TiledColumnsLayout.prototype, 'gap', {\r\n    set: function(value) {\r\n        this._verticalGap = value;\r\n        this._horizontalGap = value;\r\n        this._needUpdate = true;\r\n    },\r\n    get: function() {\r\n        return this._verticalGap;\r\n    }\r\n});\r\n","var Layout = require('./Layout');\r\n\r\n/**\r\n * TiledLayout a layout for tiled rows/columns\r\n *\r\n * @class TiledLayout\r\n * @extends PIXI.layout.Layout\r\n * @memberof PIXI.layout\r\n * @constructor\r\n */\r\nfunction TiledLayout() {\r\n    Layout.call(this);\r\n    this._useSquareTiles = false;\r\n    this._horizontalGap = 0;\r\n    this._verticalGap = 0;\r\n    this._tileHorizontalAlign = TiledLayout.TILE_HORIZONTAL_ALIGN_CENTER;\r\n    this._tileVerticalAlign = TiledLayout.TILE_VERTICAL_ALIGN_MIDDLE;\r\n    this._paging = TiledLayout.PAGING_NONE;\r\n    this._orientation = TiledLayout.ORIENTATION_ROWS;\r\n    this._needUpdate = true;\r\n}\r\n\r\nTiledLayout.prototype = Object.create( Layout.prototype );\r\nTiledLayout.prototype.constructor = TiledLayout;\r\nmodule.exports = TiledLayout;\r\n\r\n\r\nTiledLayout.ORIENTATION_ROWS = 'rows';\r\nTiledLayout.ORIENTATION_COLUMNS = 'columns';\r\n\r\n/**\r\n * If an item height is smaller than the height of a tile, the item will\r\n * be aligned to the top edge of the tile.\r\n *\r\n * @property TILE_VERTICAL_ALIGN_TOP\r\n * @static\r\n */\r\nTiledLayout.TILE_VERTICAL_ALIGN_TOP = 'top';\r\n\r\n/**\r\n * If an item height is smaller than the height of a tile, the item will\r\n * be aligned to the middle of the tile.\r\n *\r\n * @property TILE_VERTICAL_ALIGN_MIDDLE\r\n * @static\r\n */\r\nTiledLayout.TILE_VERTICAL_ALIGN_MIDDLE = 'middle';\r\n\r\n/**\r\n * If an item height is smaller than the height of a tile, the item will\r\n * be aligned to the bottom edge of the tile.\r\n *\r\n * @property TILE_VERTICAL_ALIGN_BOTTOM\r\n * @static\r\n */\r\nTiledLayout.TILE_VERTICAL_ALIGN_BOTTOM = 'bottom';\r\n\r\n/**\r\n * The item will be resized to fit the height of the tile.\r\n *\r\n * @property TILE_VERTICAL_ALIGN_JUSTIFY\r\n * @static\r\n */\r\nTiledLayout.TILE_VERTICAL_ALIGN_JUSTIFY = 'justify';\r\n\r\n/**\r\n * If an item width is smaller than the width of a tile, the item will\r\n * be aligned to the left edge of the tile.\r\n *\r\n * @property TILE_HORIZONTAL_ALIGN_LEFT\r\n * @static\r\n */\r\nTiledLayout.TILE_HORIZONTAL_ALIGN_LEFT = 'left';\r\n\r\n/**\r\n * If an item width is smaller than the width of a tile, the item will\r\n * be aligned to the center of the tile.\r\n *\r\n * @property TILE_HORIZONTAL_ALIGN_CENTER\r\n * @static\r\n */\r\nTiledLayout.TILE_HORIZONTAL_ALIGN_CENTER = 'center';\r\n\r\n/**\r\n * If an item width is smaller than the width of a tile, the item will\r\n * be aligned to the right edge of the tile.\r\n *\r\n * @property TILE_HORIZONTAL_ALIGN_RIGHT\r\n * @static\r\n */\r\nTiledLayout.TILE_HORIZONTAL_ALIGN_RIGHT = 'right';\r\n\r\n/**\r\n * The item will be resized to fit the width of the tile.\r\n *\r\n * @property TILE_HORIZONTAL_ALIGN_JUSTIFY\r\n * @static\r\n */\r\nTiledLayout.TILE_HORIZONTAL_ALIGN_JUSTIFY = 'justify';\r\n\r\n/**\r\n * The items will be positioned in pages horizontally from left to right.\r\n *\r\n * @property PAGING_HORIZONTAL\r\n * @static\r\n */\r\nTiledLayout.PAGING_HORIZONTAL = 'horizontal';\r\n\r\n/**\r\n * The items will be positioned in pages vertically from top to bottom.\r\n *\r\n * @property PAGING_VERTICAL\r\n * @static\r\n */\r\nTiledLayout.PAGING_VERTICAL = 'vertical';\r\n\r\n\r\n\r\n/**\r\n * calculate layout for container\r\n */\r\nTiledLayout.prototype.layoutContainer = function(container) {\r\n    return this.layout(container.children, container.width, container.height);\r\n};\r\n\r\n\r\n/**\r\n * Positions (and possibly resizes) the supplied items.\r\n *\r\n * @method layout\r\n * @param items items that will be layouted\r\n * @param maxWidth\r\n * @param maxHeight\r\n */\r\nTiledLayout.prototype.layout = function (items, maxWidth, maxHeight) {\r\n    var _rows = this._orientation === TiledLayout.ORIENTATION_ROWS;\r\n    if(items.length === 0) {\r\n        return [0, 0];\r\n    }\r\n\r\n    maxWidth = maxWidth || NaN;\r\n    maxHeight = maxHeight || NaN;\r\n    \r\n    // width/height the current layout takes\r\n    var width = 0;\r\n    var height = 0;\r\n\r\n    var i, item;\r\n    var tileWidth = 0;\r\n    var tileHeight = 0;\r\n\r\n    // get size for tiles by saving the highest/widest tile.\r\n    for(i = 0; i < items.length; i++) {\r\n        item = items[i];\r\n        if(!item) {\r\n            continue;\r\n        }\r\n        \r\n        tileWidth = Math.max(tileWidth, item.width);\r\n        tileHeight = Math.max(tileHeight, item.height);\r\n    }\r\n\r\n    // make tiles square\r\n    if (this._useSquareTiles) {\r\n        if (tileWidth > tileHeight) {\r\n            tileHeight = tileWidth;\r\n        } else if (tileHeight > tileWidth) {\r\n            tileWidth = tileHeight;\r\n        }\r\n    }\r\n\r\n    // calculate tiles needed (and their width/height)\r\n    var availableWidth = NaN;\r\n    var availableHeight = NaN;\r\n\r\n    var horizontalTileCount = _rows ? items.length : 1;\r\n\r\n    if(!isNaN(maxWidth)) {\r\n        availableWidth = maxWidth;\r\n        horizontalTileCount = (maxWidth -\r\n            this._paddingLeft - this._paddingRight +\r\n            this._horizontalGap) / (tileWidth + this._horizontalGap);\r\n    }\r\n    horizontalTileCount = Math.floor(Math.max(horizontalTileCount, 1));\r\n\r\n    var verticalTileCount = _rows ? 1 : items.length;\r\n    if(!isNaN(maxHeight)) {\r\n        availableHeight = maxHeight;\r\n        verticalTileCount = (maxHeight -\r\n            this._paddingTop - this._paddingBottom +\r\n            this._verticalGap) / (tileHeight + this._verticalGap);\r\n    }\r\n    verticalTileCount = Math.floor(Math.max(verticalTileCount, 1));\r\n    \r\n    var startX = this._paddingLeft;\r\n    var startY = this._paddingTop;\r\n\r\n    var perPage = horizontalTileCount * verticalTileCount;\r\n    var pageIndex = 0;\r\n    var nextPageStartIndex = perPage;\r\n    var pageStart = _rows ? startX : startY;\r\n    var positionX = startX;\r\n    var positionY = startY;\r\n    var itemIndex = 0;\r\n    for(i = 0; i < items.length; i++)\r\n    {\r\n        item = items[i];\r\n        if (_rows) {\r\n            if(itemIndex !== 0 && itemIndex % horizontalTileCount === 0)\r\n            {\r\n                positionX = pageStart;\r\n                positionY += tileHeight + this._verticalGap;\r\n            }\r\n        } else { // columns\r\n            if(itemIndex !== 0 && i % verticalTileCount === 0)\r\n            {\r\n                positionX += tileWidth + this._horizontalGap;\r\n                positionY = pageStart;\r\n            }\r\n        }\r\n        if(itemIndex === nextPageStartIndex) {\r\n            pageIndex++;\r\n            nextPageStartIndex += perPage;\r\n\r\n            //we can use availableWidth and availableHeight here without\r\n            //checking if they're NaN because we will never reach a\r\n            //new page without them already being calculated.\r\n            if (_rows) {\r\n                if(this._paging === TiledLayout.PAGING_HORIZONTAL)\r\n                {\r\n                    positionX = pageStart === startX + availableWidth * pageIndex;\r\n                    positionY = startY;\r\n                } else if(this._paging === TiledLayout.PAGING_VERTICAL) {\r\n                    positionY = startY + availableHeight * pageIndex;\r\n                }\r\n            } else { // columns\r\n                if(this._paging === TiledLayout.PAGING_HORIZONTAL) {\r\n                    positionX = startX + availableWidth * pageIndex;\r\n                } else if(this._paging === TiledLayout.PAGING_VERTICAL) {\r\n                    positionX = startX;\r\n                    positionY = pageStart = startY + availableHeight * pageIndex;\r\n                }\r\n            }\r\n        }\r\n        if(item) {\r\n            switch(this._tileHorizontalAlign) {\r\n                case TiledLayout.TILE_HORIZONTAL_ALIGN_JUSTIFY:\r\n                    item.x = positionX;\r\n                    item.width = tileWidth;\r\n                    break;\r\n                case TiledLayout.TILE_HORIZONTAL_ALIGN_LEFT:\r\n                    item.x = positionX;\r\n                    break;\r\n                case TiledLayout.TILE_HORIZONTAL_ALIGN_RIGHT:\r\n                    item.x = positionX + tileWidth - item.width;\r\n                    break;\r\n                default: //center or unknown\r\n                    item.x = positionX + (tileWidth - item.width) / 2;\r\n            }\r\n            switch(this._tileVerticalAlign) {\r\n                case TiledLayout.TILE_VERTICAL_ALIGN_JUSTIFY:\r\n                    item.y = positionY;\r\n                    item.height = tileHeight;\r\n                    break;\r\n                case TiledLayout.TILE_VERTICAL_ALIGN_TOP:\r\n                    item.y = positionY;\r\n                    break;\r\n                case TiledLayout.TILE_VERTICAL_ALIGN_BOTTOM:\r\n                    item.y = positionY + tileHeight - item.height;\r\n                    break;\r\n                default: //middle or unknown\r\n                    item.y = positionY + (tileHeight - item.height) / 2;\r\n            }\r\n        }\r\n        if (_rows) {\r\n            positionX += tileWidth + this._horizontalGap;\r\n        } else { // columns\r\n            positionY += tileHeight + this._verticalGap;\r\n        }\r\n        itemIndex++;\r\n    }\r\n\r\n    this._needUpdate = false;\r\n    return [width, height];\r\n};\r\n\r\n/**\r\n * use same width and height for the tiles (calculated by biggest square)\r\n *\r\n * @property useSquareTiles\r\n * @type Boolean\r\n */\r\nObject.defineProperty(TiledLayout.prototype, 'useSquareTiles', {\r\n    set: function(useSquareTiles) {\r\n        this._useSquareTiles = useSquareTiles;\r\n        this._needUpdate = true;\r\n    },\r\n    get: function() {\r\n        return this._useSquareTiles;\r\n    }\r\n});\r\n","var TiledLayout = require('./TiledLayout');\r\n\r\n/**\r\n * Tiled rows Layout\r\n * (roughly based on starling TiledRowsLayout)\r\n *\r\n * @class TiledRowsLayout\r\n * @extends PIXI.layout.TiledLayout\r\n * @memberof PIXI.layout\r\n * @constructor\r\n */\r\nfunction TiledRowsLayout() {\r\n    TiledLayout.call(this);\r\n    this._paging = TiledLayout.PAGING_HORIZONTAL;\r\n    this._orientation = TiledLayout.ORIENTATION_ROWS;\r\n}\r\n\r\nTiledRowsLayout.prototype = Object.create( TiledLayout.prototype );\r\nTiledRowsLayout.prototype.constructor = TiledRowsLayout;\r\nmodule.exports = TiledRowsLayout;\r\n\r\n/**\r\n * Quickly sets both <code>horizontalGap</code> and <code>verticalGap</code>\r\n * to the same value. The <code>gap</code> getter always returns the\r\n * value of <code>horizontalGap</code>, but the value of\r\n * <code>verticalGap</code> may be different.\r\n *\r\n * @default 0\r\n *\r\n * @see #_horizontalGap\r\n * @see #_verticalGap\r\n *\r\n * @property gap\r\n * @type Number\r\n */\r\nObject.defineProperty(TiledRowsLayout.prototype, 'gap', {\r\n    get: function() {\r\n        return this._horizontalGap;\r\n    },\r\n    set: function(value) {\r\n        this._verticalGap = value;\r\n        this._horizontalGap = value;\r\n        this._needUpdate = true;\r\n    }\r\n});\r\n","var LayoutAlignment = require('./LayoutAlignment');\r\n\r\n/**\r\n * VerticalLayout - just set alignment to\r\n * LayoutAlignment.VERTICAL_ALIGNMENT\r\n *\r\n * @class VerticalLayout\r\n * @extends PIXI.layout.LayoutAlignment\r\n * @memberof PIXI.layout\r\n * @constructor\r\n */\r\nfunction VerticalLayout() {\r\n    LayoutAlignment.call(this);\r\n    this.alignment = LayoutAlignment.VERTICAL_ALIGNMENT;\r\n}\r\n\r\nVerticalLayout.prototype = Object.create( LayoutAlignment.prototype );\r\nVerticalLayout.prototype.constructor = VerticalLayout;\r\nmodule.exports = VerticalLayout;\r\n","module.exports = PIXI.shapes = {\r\n    Shape:          require('./shapes/Shape'),\r\n    Diamond:        require('./shapes/Diamond'),\r\n    Ellipse:        require('./shapes/Ellipse'),\r\n    Line:           require('./shapes/Line'),\r\n    Rect:           require('./shapes/Rect')\r\n};\r\n","var Shape = require('./Shape');\r\n\r\n/**\r\n * basic diamond shape\r\n *\r\n * @class Diamond\r\n * @extends PIXI.shapes.Shape\r\n * @memberof PIXI.shapes\r\n * @constructor\r\n */\r\nfunction Diamond(color, alpha, width, height) {\r\n    Shape.call(this, color, alpha, width, height);\r\n}\r\n\r\nDiamond.prototype = Object.create( Shape.prototype );\r\nDiamond.prototype.constructor = Diamond;\r\nmodule.exports = Diamond;\r\n\r\n/**\r\n * draw the diamond during redraw.\r\n *\r\n * @method _drawShape\r\n * @private\r\n */\r\nDiamond.prototype._drawShape = function() {\r\n    this.moveTo(this._width/2, 0)\r\n        .lineTo(this._width, this._height/2)\r\n        .lineTo(this._width/2, this._height)\r\n        .lineTo(0, this._height/2)\r\n        .lineTo(this._width/2, 0);\r\n};\r\n","var Shape = require('./Shape');\r\n\r\n/**\r\n * basic ellipse shape\r\n *\r\n * @class Ellipse\r\n * @extends PIXI.shape.Shape\r\n * @memberof PIXI.shape\r\n * @constructor\r\n */\r\nfunction Ellipse(color, alpha, width, height) {\r\n    Shape.call(this, color, alpha, width, height);\r\n}\r\n\r\nEllipse.prototype = Object.create( Shape.prototype );\r\nEllipse.prototype.constructor = Ellipse;\r\nmodule.exports = Ellipse;\r\n\r\n/**\r\n * draw the ellipse during redraw.\r\n *\r\n * @method _drawShape\r\n * @private\r\n */\r\nEllipse.prototype._drawShape = function() {\r\n    \r\n\r\n    this.drawEllipse(this.width/2, this.height/2, \r\n        Math.abs(this.width/2), \r\n        Math.abs(this.height/2));\r\n};\r\n","var Shape = require('./Shape');\r\n\r\n/**\r\n * basic line\r\n *\r\n * @class Line\r\n * @extends PIXI.shape.Shape\r\n * @memberof PIXI.shape\r\n * @constructor\r\n */\r\n\r\nfunction Line(color, alpha, width, height, lineWidth, reverse) {\r\n    this._reverse = reverse;\r\n    Shape.call(this, color, alpha, width, height);\r\n    this.lineWidth = lineWidth || 1;\r\n}\r\n\r\nLine.prototype = Object.create( Shape.prototype );\r\nLine.prototype.constructor = Line;\r\nmodule.exports = Line;\r\n\r\n/**\r\n * draw the rect during redraw. will use drawRoundRect if a radius is provided.\r\n *\r\n * @method _drawShape\r\n * @private\r\n */\r\nLine.prototype._drawShape = function() {\r\n    if (this.reverse) {\r\n        this.moveTo(this._width, 0);\r\n        this.lineTo(0, this._height);\r\n    } else {\r\n        this.moveTo(0, 0);\r\n        this.lineTo(this._width,this._height);\r\n    }\r\n};\r\n\r\n/**\r\n * The radius of the rectangle border, setting this will redraw the component.\r\n *\r\n * @property color\r\n * @type Number\r\n */\r\nObject.defineProperty(Line.prototype, 'reverse', {\r\n    get: function() {\r\n        return this._reverse;\r\n    },\r\n    set: function(reverse) {\r\n        this._reverse = reverse;\r\n        this.invalid = true;\r\n    }\r\n});\r\n\r\n\r\n/**\r\n * update before draw call\r\n * Line has to be drawn different than other Shapes\r\n *\r\n * @method redraw\r\n */\r\nLine.prototype.redraw = function() {\r\n    if(!this.invalid) {\r\n        return;\r\n    }\r\n\r\n    var lineWidth = this.lineWidth;\r\n    this.clear();\r\n    this.lineStyle(lineWidth, this.color);\r\n    this._drawShape();\r\n\r\n    this.invalid = false;\r\n};\r\n","var Shape = require('./Shape');\r\n\r\n/**\r\n * basic rectangular shape\r\n *\r\n * @class Rect\r\n * @extends PIXI.shapes.Shape\r\n * @memberof PIXI.shapes\r\n * @constructor\r\n */\r\n\r\nfunction Rect(color, alpha, width, height, radius) {\r\n    Shape.call(this, color, alpha, width, height);\r\n    this._radius = radius;\r\n}\r\n\r\nRect.prototype = Object.create( Shape.prototype );\r\nRect.prototype.constructor = Rect;\r\nmodule.exports = Rect;\r\n\r\n/**\r\n * draw the rect during redraw. will use drawRoundRect if a radius is provided.\r\n *\r\n * @method _drawShape\r\n * @private\r\n */\r\nRect.prototype._drawShape = function() {\r\n    if (this.radius) {\r\n        this.drawRoundedRect(\r\n            Math.min(this._width, 0), \r\n            Math.min(this._height, 0), \r\n            Math.abs(this._width),\r\n            Math.abs(this._height),\r\n            this.radius);\r\n    } else {\r\n        this.drawRect(\r\n            Math.min(this._width, 0), \r\n            Math.min(this._height, 0), \r\n            Math.abs(this._width),\r\n            Math.abs(this._height));\r\n    }\r\n};\r\n\r\n/**\r\n * The radius of the rectangle border, setting this will redraw the component.\r\n *\r\n * @property color\r\n * @type Number\r\n */\r\nObject.defineProperty(Rect.prototype, 'radius', {\r\n    get: function() {\r\n        return this._radius;\r\n    },\r\n    set: function(radius) {\r\n        this._radius = radius;\r\n        this.invalid = true;\r\n    }\r\n});\r\n","/**\r\n * shape base class\r\n *\r\n * @class Shape\r\n * @extends PIXI.Graphics\r\n * @memberof PIXI.shapes\r\n * @constructor\r\n */\r\nfunction Shape(color, alpha, width, height) {\r\n    PIXI.Graphics.call(this);\r\n    this._color = color;\r\n    this._alpha = alpha || 1.0;\r\n    this._width = width;\r\n    this._height = height;\r\n    this.invalid = true;\r\n}\r\n\r\nShape.prototype = Object.create( PIXI.Graphics.prototype );\r\nShape.prototype.constructor = Shape;\r\nmodule.exports = Shape;\r\n\r\n// setter/getter\r\n/**\r\n * The width of the shape, setting this will redraw the component.\r\n *\r\n * @property width\r\n * @type Number\r\n */\r\nObject.defineProperty(Shape.prototype, 'width', {\r\n    get: function() {\r\n        return this._width;\r\n    },\r\n    set: function(width) {\r\n        this._width = width;\r\n        this.invalid = true;\r\n    }\r\n});\r\n\r\n/**\r\n * The height of the shape, setting this will redraw the component.\r\n *\r\n * @property height\r\n * @type Number\r\n */\r\nObject.defineProperty(Shape.prototype, 'height', {\r\n    get: function() {\r\n        return this._height;\r\n    },\r\n    set: function(height) {\r\n        this._height = height;\r\n        this.invalid = true;\r\n    }\r\n});\r\n\r\n/**\r\n * The fill color of the shape, setting this will redraw the component.\r\n *\r\n * @property color\r\n * @type Number\r\n */\r\n\r\nObject.defineProperty(Shape.prototype, 'color', {\r\n    get: function() {\r\n        return this._color;\r\n    },\r\n    set: function(color) {\r\n        this._color = color;\r\n        this.invalid = true;\r\n    }\r\n});\r\n\r\n/**\r\n * The alpha of the shape, setting this will redraw the component.\r\n *\r\n * @property alpha\r\n * @type Number\r\n */\r\n\r\nObject.defineProperty(Shape.prototype, 'alpha', {\r\n    get: function() {\r\n        return this._alpha;\r\n    },\r\n    set: function(alpha) {\r\n        this._alpha = alpha;\r\n        this.invalid = true;\r\n    }\r\n});\r\n\r\n/**\r\n * apply the color to the shape (called during redraw)\r\n *\r\n * @method applyColor\r\n */\r\nShape.prototype.applyColor = function() {\r\n    this.beginFill(this.color, this.alpha);\r\n};\r\n\r\n/**\r\n * apply the border around shape (called during redraw)\r\n *\r\n * @method drawBorder\r\n */\r\nShape.prototype.drawBorder = function() {\r\n    if (this.border) {\r\n        this.lineStyle(this.border, this.borderColor);\r\n    }\r\n};\r\n\r\n/**\r\n * draw the shape during redraw. defaults to a simple rect\r\n *\r\n * @method _drawShape\r\n * @private\r\n */\r\nShape.prototype._drawShape = function() {\r\n    // default shape is a rect\r\n    this.drawRect(\r\n        Math.min(this._width, 0), \r\n        Math.min(this._height, 0), \r\n        Math.abs(this._width),\r\n        Math.abs(this._height));\r\n};\r\n\r\n\r\nShape.prototype.updateTransform = function() {\r\n    this.redraw();\r\n\r\n    PIXI.Graphics.prototype.updateTransform.call(this);\r\n};\r\n\r\n\r\n/**\r\n * update before draw call\r\n * redraw control for current state from theme\r\n *\r\n * @method redraw\r\n */\r\nShape.prototype.redraw = function() {\r\n    if(!this.invalid) {\r\n        return;\r\n    }\r\n\r\n    this.clear();\r\n    this.applyColor();\r\n    this.drawBorder();\r\n    this._drawShape();\r\n\r\n    this.invalid = false;\r\n};\r\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty;\n\n//\n// We store our EE objects in a plain object whose properties are event names.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// `~` to make sure that the built-in object properties are not overridden or\n// used as an attack vector.\n// We also assume that `Object.create(null)` is available when the event name\n// is an ES6 Symbol.\n//\nvar prefix = typeof Object.create !== 'function' ? '~' : false;\n\n/**\n * Representation of a single EventEmitter function.\n *\n * @param {Function} fn Event handler to be called.\n * @param {Mixed} context Context for function execution.\n * @param {Boolean} [once=false] Only emit once\n * @api private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Minimal EventEmitter interface that is molded against the Node.js\n * EventEmitter interface.\n *\n * @constructor\n * @api public\n */\nfunction EventEmitter() { /* Nothing to set */ }\n\n/**\n * Hold the assigned EventEmitters by name.\n *\n * @type {Object}\n * @private\n */\nEventEmitter.prototype._events = undefined;\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @api public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var events = this._events\n    , names = []\n    , name;\n\n  if (!events) return names;\n\n  for (name in events) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return a list of assigned event listeners.\n *\n * @param {String} event The events that should be listed.\n * @param {Boolean} exists We only need to know if there are listeners.\n * @returns {Array|Boolean}\n * @api public\n */\nEventEmitter.prototype.listeners = function listeners(event, exists) {\n  var evt = prefix ? prefix + event : event\n    , available = this._events && this._events[evt];\n\n  if (exists) return !!available;\n  if (!available) return [];\n  if (available.fn) return [available.fn];\n\n  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {\n    ee[i] = available[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Emit an event to all registered event listeners.\n *\n * @param {String} event The name of the event.\n * @returns {Boolean} Indication if we've emitted an event.\n * @api public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events || !this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if ('function' === typeof listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Register a new EventListener for the given event.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} [context=this] The context of the function.\n * @api public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  var listener = new EE(fn, context || this)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events) this._events = prefix ? {} : Object.create(null);\n  if (!this._events[evt]) this._events[evt] = listener;\n  else {\n    if (!this._events[evt].fn) this._events[evt].push(listener);\n    else this._events[evt] = [\n      this._events[evt], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Add an EventListener that's only called once.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} [context=this] The context of the function.\n * @api public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  var listener = new EE(fn, context || this, true)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events) this._events = prefix ? {} : Object.create(null);\n  if (!this._events[evt]) this._events[evt] = listener;\n  else {\n    if (!this._events[evt].fn) this._events[evt].push(listener);\n    else this._events[evt] = [\n      this._events[evt], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Remove event listeners.\n *\n * @param {String} event The event we want to remove.\n * @param {Function} fn The listener that we need to find.\n * @param {Mixed} context Only remove listeners matching this context.\n * @param {Boolean} once Only remove once listeners.\n * @api public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events || !this._events[evt]) return this;\n\n  var listeners = this._events[evt]\n    , events = [];\n\n  if (fn) {\n    if (listeners.fn) {\n      if (\n           listeners.fn !== fn\n        || (once && !listeners.once)\n        || (context && listeners.context !== context)\n      ) {\n        events.push(listeners);\n      }\n    } else {\n      for (var i = 0, length = listeners.length; i < length; i++) {\n        if (\n             listeners[i].fn !== fn\n          || (once && !listeners[i].once)\n          || (context && listeners[i].context !== context)\n        ) {\n          events.push(listeners[i]);\n        }\n      }\n    }\n  }\n\n  //\n  // Reset the array, or remove it completely if we have no more listeners.\n  //\n  if (events.length) {\n    this._events[evt] = events.length === 1 ? events[0] : events;\n  } else {\n    delete this._events[evt];\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners or only the listeners for the specified event.\n *\n * @param {String} event The event want to remove all listeners for.\n * @api public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  if (!this._events) return this;\n\n  if (event) delete this._events[prefix ? prefix + event : event];\n  else this._events = prefix ? {} : Object.create(null);\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// This function doesn't apply anymore.\n//\nEventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n  return this;\n};\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","var Control = require('../core/Control');\r\n\r\n/**\r\n * entry point for your application, makes some assumptions, (e.g. that you\r\n * always want fullscreen) and shortcuts some fancy stuff like a gradient\r\n * background.\r\n *\r\n * @class Application\r\n * @extends GOWN.Control\r\n * @memberof GOWN\r\n * @constructor\r\n * @param config {Object} - equals the renderer config for pixi with an\r\n *  exception: the backgroundColor is an Array a of colors it will drawn as\r\n *  vertical gradient\r\n *  (default: {backgroundColor: 0xffffff})\r\n * @param fullscreen {Boolean}\r\n *  (default: true)\r\n * @param renderer {WebGLRenderer|CanvasRenderer}\r\n *  (default: null - will create a new renderer)\r\n * @param stage {Stage}\r\n *  (default null - will use a new PIXI.Container)\r\n */\r\nfunction Application(config, fullscreen, renderer, stage) {\r\n    var width = 800;\r\n    var height = 600;\r\n    if (fullscreen) {\r\n        width = window.innerWidth;\r\n        height = window.innerHeight;\r\n    }\r\n\r\n    if (!config) {\r\n        config = {\r\n            backgroundColor: 0xffffff\r\n        };\r\n    }\r\n\r\n    var _background; // to store background if it is an array because we want\r\n                     // to set the backgroundColor in config to a hex value\r\n    if (!stage || !renderer) {\r\n        stage = new PIXI.Container();\r\n        if (config.backgroundColor && config.backgroundColor instanceof Array) {\r\n            _background = config.backgroundColor;\r\n            config.backgroundColor = 0xffffff;\r\n        }\r\n        this._background = config.backgroundColor;\r\n        renderer = PIXI.autoDetectRenderer(width, height, config);\r\n        document.body.appendChild(renderer.view);\r\n    }\r\n    /* jshint ignore:start */\r\n    this._stage = stage;\r\n    this._renderer = renderer;\r\n    /* jshint ignore:end */\r\n    this._width = renderer.width;\r\n    this._height = renderer.height;\r\n\r\n    Control.call(this);\r\n    stage.addChild(this);\r\n\r\n    if (_background) {\r\n        this.background = _background;\r\n    }\r\n    this.fullscreen = fullscreen === undefined || fullscreen;\r\n\r\n    this.animate();\r\n}\r\n\r\nApplication.prototype = Object.create( Control.prototype );\r\nApplication.prototype.constructor = Application;\r\nmodule.exports = Application;\r\n\r\n/**\r\n * call requestAnimationFrame to render the application at max. FPS\r\n *\r\n * @method animate\r\n */\r\n/* jshint ignore:start */\r\nApplication.prototype.animate = function() {\r\n    var scope = this;\r\n    var animate = function() {\r\n        if (scope._stage) {\r\n            scope._renderer.render(scope._stage);\r\n            requestAnimationFrame(animate);\r\n        }\r\n    };\r\n    requestAnimationFrame(animate);\r\n};\r\n/* jshint ignore:end */\r\n\r\n/**\r\n * creates a gradient rect that can be used as background\r\n * (uses a separate canvas to create a new Texture)\r\n *\r\n * @method _createGradientRect\r\n * @private\r\n */\r\nApplication.prototype._createGradientRect = function(gradient, width, height) {\r\n    var bgCanvas = document.createElement('canvas');\r\n    bgCanvas.width = width || 256;\r\n    bgCanvas.height = height || 256;\r\n    var ctx = bgCanvas.getContext('2d');\r\n    var linearGradient = ctx.createLinearGradient(0, 0, 0, bgCanvas.height);\r\n    for (var i = 0; i < gradient.length; i++) {\r\n        var color = gradient[i];\r\n        if (typeof(color) === 'number') {\r\n            color = '#' +  gradient[i].toString(16);\r\n        }\r\n        linearGradient.addColorStop(i, color);\r\n    }\r\n    ctx.fillStyle = linearGradient;\r\n    ctx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);\r\n    return PIXI.Texture.fromCanvas(bgCanvas);\r\n};\r\n\r\n/**\r\n * clean application: remove event listener, free memory\r\n * (can also remove the canvas from the DOM tree if wanted)\r\n *\r\n * @method destroy\r\n * @param [destroyChildren=false] {boolean} if set to true, all the children will have their destroy method called as well\r\n * @param [removeCanvas=true] {boolean} destroys the canvas and remove it from the dom tree\r\n */\r\nApplication.prototype.destroy = function(destroyChildren, removeCanvas) {\r\n    removeCanvas = removeCanvas === undefined || removeCanvas;\r\n    this._removeBackground();\r\n    this.fullscreen = false; // remove event listener on resize using setter\r\n    PIXI.Container.prototype.destroy.call(this, destroyChildren);\r\n    if (removeCanvas) {\r\n        document.body.removeChild(this._renderer.view);\r\n    }\r\n    this._stage = null;\r\n    this._renderer = null;\r\n};\r\n\r\n/**\r\n * called when the browser window / the application is resized\r\n *\r\n * @method onresize\r\n */\r\nApplication.prototype.onresize = function() {\r\n    this._width = window.innerWidth;\r\n    this._height = window.innerHeight;\r\n    this._renderer.resize(this._width, this._height);\r\n    if (this.bg) {\r\n        this.bg.width = this._width;\r\n        this.bg.height = this._height;\r\n    }\r\n    this.emit('resize', this._width, this._height);\r\n};\r\n\r\n/**\r\n * remove background\r\n * @method _removeBackground\r\n * @private\r\n */\r\nApplication.prototype._removeBackground = function() {\r\n    if (this.bg) {\r\n        this.removeChild(this.bg);\r\n        this.bg = null;\r\n    }\r\n};\r\n\r\n/**\r\n * set fullscreen and resize to screen size\r\n *\r\n * @property enabled\r\n * @type Boolean\r\n */\r\nObject.defineProperty(Application.prototype, 'fullscreen', {\r\n    get: function() {\r\n        return this._fullscreen;\r\n    },\r\n    set: function(value) {\r\n        if (this._fullscreen && !value) {\r\n            window.removeEventListener('resize', this._onresize);\r\n        } else if (!this._fullscreen && value) {\r\n            this._renderer.view.style.top = 0;\r\n            this._renderer.view.style.left = 0;\r\n            this._renderer.view.style.right = 0;\r\n            this._renderer.view.style.bottom = 0;\r\n            this._renderer.view.style.position = 'absolute';\r\n            this._onresize = this.onresize.bind(this);\r\n            window.addEventListener('resize', this._onresize);\r\n        }\r\n        this._fullscreen = value;\r\n    }\r\n});\r\n\r\n/**\r\n * set and draw background\r\n *\r\n * @property enabled\r\n * @type Boolean\r\n */\r\nObject.defineProperty(Application.prototype, 'background', {\r\n    get: function() {\r\n        return this._background;\r\n    },\r\n    set: function(value) {\r\n        if (value === this._background) {\r\n            return;\r\n        }\r\n        this._removeBackground();\r\n        if (value instanceof Array) {\r\n            this.bg = new PIXI.Sprite(this._createGradientRect(value));\r\n            this.bg.width = this._width;\r\n            this.bg.height = this._height;\r\n            this.addChildAt(this.bg, 0);\r\n        } else {\r\n            this._renderer.backgroundColor = value;\r\n        }\r\n        this._background = value;\r\n    }\r\n});\r\n","var Skinable = require('../core/Skinable');\r\nvar ScaleContainer = require('../utils/ScaleContainer');\r\n\r\n/**\r\n * The basic Button with 3 states (up, down and hover) and a label that is\r\n * centered on it\r\n *\r\n * @class Button\r\n * @extends GOWN.Skinable\r\n * @memberof GOWN\r\n * @constructor\r\n */\r\nfunction Button(theme, skinName) {\r\n    this.skinName = skinName || Button.SKIN_NAME;\r\n    this._validStates = this._validStates || Button.stateNames;\r\n    Skinable.call(this, theme);\r\n    this.handleEvent('up');\r\n\r\n    this.updateLabel = false; // label text changed\r\n\r\n    this.touchstart = this.mousedown;\r\n    this.touchend = this.mouseupoutside = this.mouseup;\r\n    this.touchendoutside = this.mouseout;\r\n}\r\n\r\nButton.prototype = Object.create( Skinable.prototype );\r\nButton.prototype.constructor = Button;\r\nmodule.exports = Button;\r\n\r\n// name of skin that will be applied\r\nButton.SKIN_NAME = 'button';\r\n\r\n// Identifier for the different button states\r\n/**\r\n * Up state: mouse button is released or finger is removed from the screen\r\n *\r\n * @property UP\r\n * @static\r\n * @final\r\n * @type String\r\n */\r\nButton.UP = 'up';\r\n\r\n/**\r\n * Down state: mouse button is pressed or finger touches the screen\r\n *\r\n * @property DOWN\r\n * @static\r\n * @final\r\n * @type String\r\n */\r\nButton.DOWN = 'down';\r\n\r\n/**\r\n * Hover state: mouse pointer hovers over the button\r\n * (ignored on mobile)\r\n *\r\n * @property HOVER\r\n * @static\r\n * @final\r\n * @type String\r\n */\r\nButton.HOVER = 'hover';\r\n\r\n/**\r\n * names of possible states for a button\r\n *\r\n * @property stateNames\r\n * @static\r\n * @final\r\n * @type String\r\n */\r\nButton.stateNames = [\r\n    Button.DOWN, Button.HOVER, Button.UP\r\n];\r\n\r\n// triggered event name for button\r\nButton.TRIGGERED = 'triggered';\r\n\r\n/**\r\n * initiate all skins first\r\n * (to prevent flickering)\r\n *\r\n * @method preloadSkins\r\n */\r\nButton.prototype.preloadSkins = function() {\r\n    for (var i = 0; i < this._validStates.length; i++) {\r\n        var name = this._validStates[i];\r\n        this.fromSkin(name, this.skinLoaded);\r\n    }\r\n};\r\n\r\n/**\r\n * skin has been loaded (see preloadSkins) and stored into the skinCache.\r\n * add to container, hide and resize\r\n *\r\n * @method skinLoaded\r\n */\r\nButton.prototype.skinLoaded = function(skin) {\r\n    this.addChildAt(skin, 0);\r\n    skin.alpha = 0.0;\r\n    if (this.width) {\r\n        skin.width = this.width;\r\n    } else if (skin.minWidth) {\r\n        this.width = skin.width = skin.minWidth;\r\n    }\r\n    if (this.height) {\r\n        skin.height = this.height;\r\n    } else if (skin.minHeight) {\r\n        this.height = skin.height = skin.minHeight;\r\n    }\r\n}\r\n\r\nButton.prototype.mousedown = function() {\r\n    this.handleEvent(Button.DOWN);\r\n};\r\n\r\nButton.prototype.mouseup = function() {\r\n    this.handleEvent(Button.UP);\r\n};\r\n\r\nButton.prototype.mousemove = function() {\r\n};\r\n\r\nButton.prototype.mouseover = function() {\r\n    this.handleEvent(Button.HOVER);\r\n};\r\n\r\nButton.prototype.mouseout = function() {\r\n    this.handleEvent('out');\r\n};\r\n\r\n\r\n/**\r\n * update width/height of the button\r\n *\r\n * @method updateDimensions\r\n */\r\nButton.prototype.updateDimensions = function() {\r\n    var width = this.worldWidth;\r\n    var height = this.worldHeight;\r\n    if (this.hitArea) {\r\n        this.hitArea.width = width;\r\n        this.hitArea.height = height;\r\n    } else {\r\n        this.hitArea = new PIXI.Rectangle(0, 0, width, height);\r\n    }\r\n    for (var i = 0; i < this._validStates.length; i++) {\r\n        var name = this._validStates[i];\r\n        var skin = this.skinCache[name];\r\n        if (skin) {\r\n            skin.width = width;\r\n            skin.height = height;\r\n        }\r\n    }\r\n\r\n    if(this.labelText) {\r\n        var scaleY = height / this._height;\r\n        this.labelText.style.fontSize = this.theme.textStyle.fontSize * scaleY;\r\n        this.labelText.style = this.labelText.style; // trigger setter\r\n        this.updateLabelDimensions();\r\n    }\r\n};\r\n\r\n/**\r\n * handle one of the mouse/touch events\r\n *\r\n * @method handleEvent\r\n * @param type one of the valid states\r\n */\r\nButton.prototype.handleEvent = function(type) {\r\n    if (!this._enabled) {\r\n        return;\r\n    }\r\n    if (type === Button.DOWN) {\r\n        this.currentState = Button.DOWN;\r\n        this._pressed = true;\r\n    } else if (type === Button.UP) {\r\n        this._pressed = false;\r\n\r\n        if (this._over) {\r\n            // the user taps or clicks the button\r\n            this.emit(Button.TRIGGERED, this);\r\n            if (this.theme.hoverSkin) {\r\n                this.currentState = Button.HOVER;\r\n            }\r\n        } else {\r\n            this.currentState = Button.UP;\r\n        }\r\n    } else if (type === Button.HOVER) {\r\n        this._over = true;\r\n        if (this._pressed) {\r\n            this.currentState = Button.DOWN;\r\n        } else if (this.theme.hoverSkin) {\r\n            this.currentState = Button.HOVER;\r\n        }\r\n    } else  { // type === rollout and default\r\n        if (this._over) {\r\n            this._over = false;\r\n        }\r\n        this.currentState = Button.UP;\r\n    }\r\n};\r\n\r\n// performance increase to avoid using call.. (10x faster)\r\nButton.prototype.redrawSkinable = Skinable.prototype.redraw;\r\n\r\n/**\r\n * update before draw call (position label)\r\n *\r\n * @method redraw\r\n */\r\nButton.prototype.redraw = function() {\r\n    if (this.updateLabel) {\r\n        this.createLabel();\r\n    }\r\n    this.redrawSkinable();\r\n};\r\n\r\n/**\r\n * create/update a label for this button\r\n *\r\n * @method createLabel\r\n */\r\nButton.prototype.createLabel = function() {\r\n    if(this.labelText) {\r\n        this.labelText.text = this._label;\r\n        this.labelText.style = this.theme.textStyle.clone();\r\n    } else {\r\n        this.labelText = new PIXI.Text(this._label, this.theme.textStyle.clone());\r\n        this.addChild(this.labelText);\r\n    }\r\n    this.updateLabelDimensions();\r\n    this.updateLabel = false;\r\n};\r\n\r\n/**\r\n * create/update the position of the label\r\n *\r\n * @method updateLabelDimensions\r\n */\r\nButton.prototype.updateLabelDimensions = function () {\r\n    if (this.labelText && this.labelText.text &&\r\n        (this.worldWidth - this.labelText.width) >= 0 &&\r\n        (this.worldHeight - this.labelText.height) >= 0) {\r\n        this.labelText.x = Math.floor((this.worldWidth - this.labelText.width) / 2);\r\n        this.labelText.y = Math.floor((this.worldHeight - this.labelText.height) / 2);\r\n    }\r\n};\r\n\r\nButton.prototype.skinableSetTheme = Skinable.prototype.setTheme;\r\n\r\n/**\r\n * change the theme\r\n *\r\n * @method setTheme\r\n * @param theme the new theme {Theme}\r\n */\r\nButton.prototype.setTheme = function(theme) {\r\n    // this theme has other font or color settings - update the label\r\n    if (this.labelText) {\r\n        this.updateLabel = (this.updateLabel ||\r\n            this.labelText.font !== this.theme.labelFont ||\r\n            this.labelText.color !== this.theme.labelColor );\r\n    }\r\n    this.skinableSetTheme(theme);\r\n};\r\n\r\n\r\n/**\r\n * The current state (one of _validStates)\r\n *\r\n * @property currentState\r\n * @type String\r\n */\r\nObject.defineProperty(Button.prototype, 'currentState',{\r\n    get: function() {\r\n        return this._currentState;\r\n    },\r\n    set: function(value) {\r\n        if (this._currentState === value) {\r\n            return;\r\n        }\r\n        if (this._validStates.indexOf(value) < 0) {\r\n            throw new Error('Invalid state: ' + value + '.');\r\n        }\r\n        this._currentState = value;\r\n        // invalidate state so the next draw call will redraw the control\r\n        this.invalidState = true;\r\n    }\r\n});\r\n\r\n/**\r\n * Create/Update the label of the button.\r\n *\r\n * @property label\r\n * @type String\r\n */\r\nObject.defineProperty(Button.prototype, 'label', {\r\n    get: function() {\r\n        return this._label;\r\n    },\r\n    set: function(label) {\r\n        if(this._label === label) {\r\n            return;\r\n        }\r\n        this._label = label;\r\n        this.updateLabel = true;\r\n    }\r\n});\r\n","var ToggleButton = require('./ToggleButton');\r\n\r\n/**\r\n\t* A toggle control that contains a label and a box that may be checked\r\n\t* or not to indicate selection.\r\n  *\r\n  * @class Check\r\n  * @extends GOWN.ToggleButton\r\n  * @memberof GOWN\r\n  * @constructor\r\n  */\r\nfunction Check(theme, skinName) {\r\n    skinName = skinName || Check.SKIN_NAME;\r\n    ToggleButton.call(this, theme, skinName);\r\n}\r\n\r\nCheck.prototype = Object.create( ToggleButton.prototype );\r\nCheck.prototype.constructor = Check;\r\nmodule.exports = Check;\r\n\r\n// name of skin that will be applied\r\nCheck.SKIN_NAME = 'check';\r\n","var Skinable = require('../core/Skinable'),\r\n    InputWrapper = require('../utils/InputWrapper');\r\n\r\n/**\r\n * InputControl used for TextInput, TextArea and everything else that\r\n * is capable of entering text\r\n *\r\n * based on PIXI.Input InputObject by Sebastian Nette,\r\n * see https://github.com/SebastianNette/PIXI.Input\r\n *\r\n * @class InputControl\r\n * @extends GOWN.Skinable\r\n * @memberof GOWN\r\n * @constructor\r\n */\r\nfunction InputControl(text, theme) {\r\n    Skinable.call(this, theme);\r\n    this.text = text || '';\r\n    // create DOM Input (if we need one)\r\n    InputWrapper.createInput();\r\n    this.hasFocus = false;\r\n\r\n    /**\r\n     * indicates if the mouse button has been pressed\r\n     * @property _mouseDown\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this._mouseDown = false;\r\n\r\n    /**\r\n     * TODO: description!\r\n     *\r\n     * @type {Array}\r\n     * @private\r\n     */\r\n    this._clipPos = [0, 0];\r\n}\r\n\r\nInputControl.prototype = Object.create( Skinable.prototype );\r\nInputControl.prototype.constructor = InputControl;\r\nmodule.exports = InputControl;\r\n\r\n/**\r\n * currently selected input control (used for tab index)\r\n *\r\n * @property currentInput\r\n * @type GOWN.InputControl\r\n * @static\r\n */\r\nInputControl.currentInput = null;\r\n\r\nInputControl.prototype.onKeyUp = function() {\r\n    this.emit('change', this);\r\n};\r\n\r\nInputControl.prototype.onEnter = function() {\r\n    this.emit('enter', this);\r\n};\r\n\r\nInputControl.prototype.onKeyDown = function() {\r\n};\r\n\r\n/**\r\n * determine where the click was made along the string\r\n *\r\n * @method clickPos\r\n * @param x\r\n * @returns {Number}\r\n */\r\nInputControl.prototype.clickPos = function(x)\r\n{\r\n\r\n    var text = this.pixiText.text,\r\n        totalWidth = this.pixiText.x,\r\n        pos = text.length;\r\n\r\n    if (x < this.textWidth(text) + totalWidth)\r\n    {\r\n        // loop through each character to identify the position\r\n        for (var i=0; i<text.length; i++)\r\n        {\r\n            totalWidth += this.textWidth(text[i]);\r\n            if (totalWidth >= x)\r\n            {\r\n                pos = i;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return this._clipPos[0] + pos;\r\n};\r\n\r\nInputControl.prototype.posToCoord = function(pos) {\r\n    var text = this.pixiText.text,\r\n        totalWidth = this.pixiText.x;\r\n\r\n    if (pos < text.length) {\r\n        return totalWidth + this.textWidth(text.substring(0, pos));\r\n    } else {\r\n        return totalWidth + this.textWidth(text);\r\n    }\r\n};\r\n\r\n/**\r\n * get text width\r\n *\r\n * @method textWidth\r\n * @param text\r\n * @returns {*}\r\n */\r\nInputControl.prototype.textWidth = function(text) {\r\n    if(!this.text._isBitmapFont)\r\n    {\r\n        var ctx = this.pixiText.context;\r\n        return ctx.measureText(text || '').width;\r\n    }\r\n    else\r\n    {\r\n        var prevCharCode = null;\r\n        var width = 0;\r\n        var data = this.pixiText._data;\r\n        for(var i = 0; i < text.length; i++) {\r\n            var charCode = text.charCodeAt(i);\r\n            var charData = data.chars[charCode];\r\n            if(!charData) {\r\n                continue;\r\n            }\r\n            if(prevCharCode && charData.kerning[prevCharCode]) {\r\n                width += charData.kerning[prevCharCode];\r\n            }\r\n            width += charData.xAdvance;\r\n            prevCharCode = charCode;\r\n        }\r\n        return width * this.pixiText._scale;\r\n    }\r\n};\r\n\r\n/**\r\n * focus on this input and set it as current\r\n *\r\n * @method focus\r\n */\r\nInputControl.prototype.focus = function () {\r\n    // is already current input\r\n    if (GOWN.InputControl.currentInput === this) {\r\n        return;\r\n    }\r\n\r\n    // drop focus\r\n    if (GOWN.InputControl.currentInput) {\r\n        GOWN.InputControl.currentInput.blur();\r\n    }\r\n\r\n    // set focus\r\n    GOWN.InputControl.currentInput = this;\r\n    this.hasFocus = true;\r\n\r\n    // check custom focus event\r\n    this.onfocus();\r\n\r\n    this.emit('focusIn', this);\r\n    /*\r\n     //TODO\r\n     // is read only\r\n     if(this.readonly) {\r\n        return;\r\n     }\r\n     */\r\n\r\n    // focus hidden input\r\n    InputWrapper.focus();\r\n};\r\n\r\n/**\r\n * determine if the input has the focus\r\n *\r\n * @property hasFocus\r\n * @type Boolean\r\n */\r\nObject.defineProperty(InputControl.prototype, 'hasFocus', {\r\n    get: function() {\r\n        return this._hasFocus;\r\n    },\r\n    set: function(focus) {\r\n        this._hasFocus = focus;\r\n    }\r\n});\r\n\r\nInputControl.prototype.onMouseUpOutside = function() {\r\n    if(this.hasFocus && !this._mouseDown)\r\n    {\r\n        this.blur();\r\n    }\r\n    this._mouseDown = false;\r\n};\r\n\r\n/**\r\n * callback to execute code on focus\r\n * @method onFocus\r\n */\r\nInputControl.prototype.onfocus = function () {\r\n};\r\n\r\n/**\r\n * blur the text input (remove focus)\r\n *\r\n * @method blur\r\n */\r\nInputControl.prototype.blur = function() {\r\n    if (GOWN.InputControl.currentInput === this) {\r\n        GOWN.InputControl.currentInput = null;\r\n        this.hasFocus = false;\r\n\r\n        // blur hidden input\r\n        InputWrapper.blur();\r\n        this.onblur();\r\n    }\r\n};\r\n\r\n/**\r\n * callback that will be executed once the text input is blurred\r\n *\r\n * @method onblur\r\n */\r\nInputControl.prototype.onblur = function() {\r\n    this.emit('focusOut', this);\r\n};\r\n\r\n// blur current input\r\nInputControl.blur = function() {\r\n    if (GOWN.InputControl.currentInput &&\r\n        !GOWN.InputControl.currentInput._mouseDown) {\r\n        GOWN.InputControl.currentInput.blur();\r\n        GOWN.InputControl.currentInput = null;\r\n    }\r\n};\r\nwindow.addEventListener('blur', InputControl.blur, false);\r\n","var Control = require('../core/Control');\r\n\r\n/**\r\n * The LayoutGroup allows you to add PIXI.js children that will be positioned\r\n *\r\n * @class LayoutGroup\r\n * @extends GOWN.Layout\r\n * @memberof GOWN\r\n * @constructor\r\n */\r\nfunction LayoutGroup(maxWidth, maxHeight) {\r\n    this.percentWidth = this.percentWidth ;\r\n    this.percentHeight = this.percentHeight;\r\n    this.maxWidth = maxWidth || Infinity;\r\n    this.maxHeight = maxHeight || Infinity;\r\n    Control.call(this);\r\n    this._needUpdate = true;\r\n}\r\n\r\nLayoutGroup.prototype = Object.create( Control.prototype );\r\nLayoutGroup.prototype.constructor = LayoutGroup;\r\nmodule.exports = LayoutGroup;\r\n\r\n/**\r\n * update before draw call (position label)\r\n *\r\n * @method redraw\r\n */\r\nLayoutGroup.prototype.redraw = function() {\r\n    var dimensionChanged = false;\r\n    if (this._width && this.maxWidth !== this._width) {\r\n        this._width = Math.min(this._width, this.maxWidth);\r\n        dimensionChanged = true;\r\n    }\r\n    if (this._height && this.maxHeight !== this._height) {\r\n        this._height = Math.min(this._height, this.maxHeight);\r\n        dimensionChanged = true;\r\n    }\r\n    if (this.layout &&\r\n        (this._needUpdate || dimensionChanged || this.layout.needUpdate)) {\r\n        this.layout.layoutContainer(this);\r\n        this._needUpdate = false;\r\n    }\r\n};\r\n\r\n/* istanbul ignore next */\r\nLayoutGroup.prototype.addChild = function(child) {\r\n    var re = Control.prototype.addChild.call(this, child);\r\n    this._needUpdate = true;\r\n    return re;\r\n};\r\n\r\n/* istanbul ignore next */\r\nLayoutGroup.prototype.addChildAt = function(child, pos) {\r\n    var re = Control.prototype.addChildAt.call(this, child, pos);\r\n    this._needUpdate = true;\r\n    return re;\r\n};\r\n\r\n/**\r\n * add some space between children\r\n *\r\n * @param space {Number}\r\n */\r\nLayoutGroup.prototype.addSpacer = function(space) {\r\n    var spacer = new Control();\r\n    spacer.width = spacer.height = space;\r\n    this.addChild(spacer);\r\n};\r\n\r\n/**\r\n * Indicates if the given child is inside the viewport (only used for scrolling)\r\n *\r\n * @method childIsRenderAble\r\n * @type boolean\r\n * @param child one child with set coordinates and dimensions\r\n * @param x X-position on the scroll-container\r\n * @param y Y-position on the scroll-container\r\n * @param width width of the viewport\r\n * @param height height of the viewport\r\n */\r\nLayoutGroup.prototype.childIsRenderAble = function(child, x, y, width, height) {\r\n    return child.x < width + x &&\r\n        child.y < height + y &&\r\n        child.x > x - child.width &&\r\n        child.y > y - child.height;\r\n};\r\n\r\n\r\n/**\r\n * Update renderable (culling of non visible objects)\r\n *\r\n * @method updateRenderable\r\n * @param x X-position on the scroll-container\r\n * @param y Y-position on the scroll-container\r\n * @param width width of the viewport\r\n * @param height height of the viewport\r\n */\r\nLayoutGroup.prototype.updateRenderable = function(x, y, width, height) {\r\n    for(var i=0, j=this.children.length; i<j; i++) {\r\n        var child = this.children[i];\r\n        child.renderable = this.childIsRenderAble(child, x, y, width, height);\r\n    }\r\n};\r\n\r\n\r\n/**\r\n * The width of the group, will get the position and the width of the right child.\r\n *\r\n * @property width\r\n * @type Number\r\n */\r\nObject.defineProperty(LayoutGroup.prototype, 'width', {\r\n    set: function(width) {\r\n        this._width = width;\r\n    },\r\n    get: function() {\r\n        if (this._width > 0) {\r\n            return this._width;\r\n        }\r\n        var width = 0;\r\n        if (this.children) {\r\n            for (var i = 0; i < this.children.length; i++) {\r\n                var child = this.getChildAt(i);\r\n                width = Math.max(width, child.x+child.width);\r\n            }\r\n        }\r\n        return width;\r\n    }\r\n});\r\n\r\n/**\r\n * The height of the group, will get the position and the height of the bottom child.\r\n *\r\n * @property width\r\n * @type Number\r\n */\r\nObject.defineProperty(LayoutGroup.prototype, 'height', {\r\n    set: function(height) {\r\n        this._height = height;\r\n    },\r\n    get: function() {\r\n        if (this._height > 0) {\r\n            return this._height;\r\n        }\r\n        var height = 0;\r\n        if (this.children) {\r\n            for (var i = 0; i < this.children.length; i++) {\r\n                var child = this.getChildAt(i);\r\n                height = Math.max(height, child.y+child.height);\r\n            }\r\n        }\r\n        return height;\r\n    }\r\n});\r\n","var Scroller = require('./Scroller');\r\nvar ListCollection = require('../data/ListCollection');\r\nvar LayoutGroup = require('./LayoutGroup');\r\nvar DefaultListItemRenderer = require('./renderers/DefaultListItemRenderer');\r\n\r\n/**\r\n * The basic list\r\n *\r\n * @class List\r\n * @extends GOWN.List\r\n * @memberof GOWN\r\n * @constructor\r\n */\r\nfunction List(dataProvider, theme) {\r\n    Scroller.call(this, theme);\r\n    this.skinName = this.skinName || List.SKIN_NAME;\r\n\r\n    // Determines if items in the list may be selected.\r\n    this._selectable = true;\r\n\r\n    // The index of the currently selected item.\r\n    this._selectedIndex = -1;\r\n\r\n    // If true multiple items may be selected at a time.\r\n    this._allowMultipleSelection = false;\r\n\r\n    // The indices of the currently selected items.\r\n    this._selectedIndices = [];\r\n\r\n    this._itemRenderer = [];\r\n    this._itemChangeHandler = this.itemChangeHandler.bind(this);\r\n    this._itemRendererChangeHandler = this.itemRendererChangeHandler.bind(this);\r\n\r\n    // create new instance of the item renderer\r\n    this._itemRendererFactory = this._itemRendererFactory || this._defaultItemRendererFactory;\r\n\r\n    // The collection of data displayed by the list.\r\n    this.dataProvider = dataProvider;\r\n\r\n    /**\r\n     * properties that will be passed down to every item\r\n     * renderer when the list validates.\r\n     */\r\n    this._itemRendererProperties = {};\r\n\r\n    // TODO: itemRendererStyleName (?)\r\n\r\n    // initialize\r\n    if (!this.viewPort) {\r\n\r\n        // We do not implement ListDataViewPort from feathers\r\n        // (most of what that it does is implemented in List directly to\r\n        //  manage the viewport)\r\n        // and instead use the normal LayoutGroup (less abstraction, less code)\r\n        this.viewPort = new LayoutGroup();\r\n    }\r\n\r\n    var layout = this._layout;\r\n\r\n    if (!layout) {\r\n        layout = new PIXI.layout.VerticalLayout();\r\n        layout.padding = 0;\r\n        layout.gap = 0;\r\n        layout.horizontalAlign = PIXI.layout.VerticalLayout.HORIZONTAL_ALIGN_JUSTIFY;\r\n        layout.verticalAlign = PIXI.layout.VerticalLayout.VERTICAL_ALIGN_TOP;\r\n    }\r\n    // use setter to set layout of the viewport\r\n    this.layout = layout;\r\n}\r\n\r\nList.prototype = Object.create( Scroller.prototype );\r\nList.prototype.constructor = List;\r\nmodule.exports = List;\r\n\r\n// name of skin that will be applied\r\nList.SKIN_NAME = 'list';\r\n\r\n/**\r\n * Dispatched when the selected item changes.\r\n */\r\nList.CHANGE = 'change';\r\n\r\n\r\n/**\r\n * A function called that is expected to return a new item renderer\r\n */\r\nList.prototype._defaultItemRendererFactory = function(theme) {\r\n    return new DefaultListItemRenderer(theme);\r\n};\r\n\r\nList.prototype.itemChangeHandler = function() {\r\n    // this code is executed when new data is added or removed\r\n    // to the dataProvider\r\n    // TODO: test code so it will handle if item is removed\r\n    // deselect removed items\r\n    var index = this._dataProvider.data.length;\r\n    if (this._selectedIndex >= index) {\r\n        this._selectedIndex = -1;\r\n    }\r\n    var indexCount = this._selectedIndices.length;\r\n    for (var i = 0; i < indexCount; i++) {\r\n        var currentIndex = this._selectedIndices[i];\r\n        if (currentIndex >= index) {\r\n            this._selectedIndices.splice(i, 1);\r\n        }\r\n    }\r\n    // force redraw\r\n    this.dataInvalid = true;\r\n};\r\n\r\n/**\r\n * select one of the item\r\n */\r\nList.prototype.selectItem = function(item) {\r\n    this.selectedIndex = this._dataProvider.data.indexOf(item);\r\n};\r\n\r\n\r\n// performance increase to avoid using call.. (10x faster)\r\nList.prototype.scrollerRedraw = Scroller.prototype.redraw;\r\n/**\r\n * update before draw call\r\n *\r\n * @method redraw\r\n */\r\nList.prototype.redraw = function() {\r\n    var basicsInvalid = this.dataInvalid;\r\n    if (basicsInvalid) {\r\n        this.refreshRenderers();\r\n    }\r\n    this.scrollerRedraw();\r\n};\r\n\r\nList.prototype.refreshRenderers = function () {\r\n    //TODO: update only new renderer\r\n    //      see ListDataViewPort --> refreshInactieRenderers\r\n    this._itemRenderer.length = 0;\r\n    if (this._dataProvider && this.viewPort) {\r\n        this.viewPort.removeChildren();\r\n        for (var i = 0; i < this._dataProvider.length; i++) {\r\n            var item = this._dataProvider.getItemAt(i);\r\n            var itemRenderer = this._itemRendererFactory(this.theme);\r\n\r\n            if (this._itemRendererProperties) {\r\n                itemRenderer.labelField = this._itemRendererProperties.labelField;\r\n            }\r\n\r\n            itemRenderer.on('change', this._itemRendererChangeHandler);\r\n            itemRenderer.data = item;\r\n            this._itemRenderer.push(itemRenderer);\r\n            this.viewPort.addChild(itemRenderer);\r\n        }\r\n    }\r\n\r\n    this.dataInvalid = false;\r\n};\r\n\r\n/**\r\n * item catch/forward renderer change event\r\n * this is thrown when the state of the itemRenderer Changes\r\n * (e.g. from unselected to selected), not when the data changes\r\n */\r\nList.prototype.itemRendererChangeHandler = function(itemRenderer, value) {\r\n    // TODO: update selected item\r\n    var i;\r\n    this._selectedIndices.length = 0;\r\n\r\n    if (!this.allowMultipleSelection) {\r\n        for (i = 0; i < this._itemRenderer.length; i++) {\r\n            if (this._itemRenderer[i] !== itemRenderer && value === true) {\r\n                this._itemRenderer[i].selected = false;\r\n            }\r\n        }\r\n        if (value === true) {\r\n            this._selectedIndices = [this._itemRenderer.indexOf(itemRenderer)];\r\n        }\r\n    } else {\r\n        for (i = 0; i < this._itemRenderer.length; i++) {\r\n            if (this._itemRenderer[i].selected === true) {\r\n                this._selectedIndices.push(i);\r\n            }\r\n        }\r\n    }\r\n\r\n    this.emit('change', itemRenderer, value);\r\n};\r\n\r\n/**\r\n * set layout and pass eventlistener to it\r\n *\r\n * @property layout\r\n * @type LayoutAlignment\r\n */\r\nObject.defineProperty(List.prototype, 'layout', {\r\n    set: function(layout) {\r\n        if (this._layout === layout) {\r\n            return;\r\n        }\r\n        if (this.viewPort) {\r\n            // this is different from feathers - there the viewport does not\r\n            // know the layout (feathers uses ListDataViewPort, not LayoutGroup\r\n            // as viewPort for List)\r\n            this.viewPort.layout = layout;\r\n        }\r\n        // TODO: this.invalidate(INVALIDATION_FLAG_LAYOUT);\r\n    },\r\n    get: function() {\r\n        return this._layout;\r\n    }\r\n});\r\n\r\n/**\r\n * set item renderer properties (e.g. labelField) and update all itemRenderer\r\n *\r\n * @property itemRendererProperties\r\n * @type LayoutAlignment\r\n */\r\nObject.defineProperty(List.prototype, 'itemRendererProperties', {\r\n    set: function(itemRendererProperties) {\r\n        this._itemRendererProperties = itemRendererProperties;\r\n        this.dataInvalid = true;\r\n    },\r\n    get: function() {\r\n        return this._itemRendererProperties;\r\n    }\r\n});\r\n\r\n\r\n/**\r\n * set item renderer factory (for custom item Renderer)\r\n *\r\n * @property itemRendererFactory\r\n * @type LayoutAlignment\r\n */\r\nObject.defineProperty(List.prototype, 'itemRendererFactory', {\r\n    set: function(itemRendererFactory) {\r\n        this._itemRendererFactory = itemRendererFactory;\r\n        this.dataInvalid = true;\r\n    },\r\n    get: function() {\r\n        return this._itemRendererFactory;\r\n    }\r\n});\r\n\r\n/**\r\n * allow/disallow multiple selection\r\n * if selection has been disallowed, deselect all but one.\r\n *\r\n * @property allowMultipleSelection\r\n * @type Boolean\r\n */\r\n Object.defineProperty(List.prototype, 'allowMultipleSelection', {\r\n     set: function(allowMultipleSelection) {\r\n         if (this._allowMultipleSelection === allowMultipleSelection) {\r\n             return;\r\n         }\r\n         this._allowMultipleSelection = allowMultipleSelection;\r\n\r\n         if (!this._allowMultipleSelection && this._selectedIndices) {\r\n             // only last index is selected\r\n             this._selectedIndices = [this._selectedIndices.pop()];\r\n         }\r\n         //TODO: this.refreshSelection();\r\n     },\r\n     get: function() {\r\n         return this._allowMultipleSelection;\r\n     }\r\n });\r\n\r\n\r\nObject.defineProperty(List.prototype, 'selectedIndex', {\r\n    set: function(selectedIndex) {\r\n        this._selectedIndex = selectedIndex;\r\n        // force redraw\r\n        this.dataInvalid = true;\r\n    },\r\n    get: function() {\r\n        return this._selectedIndex;\r\n    }\r\n});\r\n\r\n/**\r\n * dataProvider for list\r\n * the dataProvider is a sturcture thats provides the data.\r\n * in its simplest form it is a array containing the data\r\n *\r\n * @property dataProvider\r\n * @type Array\r\n */\r\nObject.defineProperty(List.prototype, 'dataProvider', {\r\n    set: function(dataProvider) {\r\n        if (this._dataProvider === dataProvider) {\r\n            return;\r\n        }\r\n        if (!(dataProvider instanceof ListCollection || dataProvider === null)) {\r\n            throw new Error('the dataProvider has to be a GOWN.ListCollection');\r\n        }\r\n\r\n        if (this._dataProvider) {\r\n            this._dataProvider.off(ListCollection.CHANGED, this._itemChangeHandler);\r\n        }\r\n        this._dataProvider = dataProvider;\r\n\r\n        //reset the scroll position because this is a drastic change and\r\n        //the data is probably completely different\r\n        this.horizontalScrollPosition = 0;\r\n        this.verticalScrollPosition = 0;\r\n\r\n        if (this._dataProvider) {\r\n            this._dataProvider.on(ListCollection.CHANGED, this._itemChangeHandler);\r\n        }\r\n\r\n        this.selectedIndex = -1;\r\n        this.dataInvalid = true;\r\n    },\r\n    get: function() {\r\n        return this._dataProvider;\r\n    }\r\n});\r\n","var ToggleButton = require('./ToggleButton');\r\n\r\n/**\r\n * PickerList allows the user to select an option from a list\r\n *\r\n * @class PickerList\r\n * @extends PIXI_UI.Control\r\n * @memberof PIXI_UI\r\n * @constructor\r\n */\r\nfunction PickerList(theme) {\r\n    this.skinName = this.skinName || PickerList.SKIN_NAME;\r\n    ToggleButton.call(this, theme);\r\n    this._dataProvider = [];\r\n\r\n    this.invalidIcon = true;\r\n}\r\n\r\nPickerList.prototype = Object.create( ToggleButton.prototype );\r\nPickerList.prototype.constructor = PickerList;\r\nmodule.exports = PickerList;\r\n\r\n// name of skin that will be applied\r\nPickerList.SKIN_NAME = 'pickerlist';\r\n\r\n/**\r\n * show icon for selection\r\n *\r\n * @method showIcon\r\n * @param skin\r\n */\r\nPickerList.prototype.showIcon = function(skin) {\r\n    if (this.iconSkin !== skin) {\r\n        if(this.iconSkin) {\r\n            this.removeChild(this.iconSkin);\r\n        }\r\n\r\n        this.addChild(skin);\r\n        this.iconSkin = skin;\r\n    }\r\n    skin.x = this.width - skin.getBounds().width - 10;\r\n    skin.y = Math.floor((this.height - skin.getBounds().height )/ 2);\r\n    this.invalidIcon = false;\r\n};\r\n\r\n/**\r\n * redraw the skin\r\n *\r\n * @method redraw\r\n */\r\nPickerList.prototype.redraw = function() {\r\n    this.redrawSkinable();\r\n    if (this.invalidIcon) {\r\n        this.fromSkin('picker_list_'+this._currentState, this.showIcon);\r\n    }\r\n};\r\n\r\n// TODO: setter/gettter for List to get selectedItem or set dataProvider\r\n// TODO: prompt\r\n// TODO: PopupManager (?)\r\n// TODO: createButton/ListItem\r\n// TODO: createList\r\n","var Scrollable = require('./Scrollable');\r\n\r\n// TODO: decreement/increment Button\r\n// TODO: thumbFactory?\r\n// TODO: this.showButtons\r\n\r\n/**\r\n * scoll bar with thumb\r\n * hosting some Viewport (e.g. a ScrollContainer or a Texture)\r\n *\r\n * @class ScrollBar\r\n * @extends GOWN.Scrollable\r\n * @memberof GOWN\r\n * @constructor\r\n */\r\nfunction ScrollBar(direction, theme) {\r\n    this.skinName = this.skinName || ScrollBar.SKIN_NAME;\r\n\r\n    this.direction = direction;\r\n    if (this.direction === undefined) {\r\n        this.direction = Scrollable.HORIZONTAL;\r\n    }\r\n    Scrollable.call(this, theme);\r\n}\r\n\r\nScrollBar.prototype = Object.create( Scrollable.prototype );\r\nScrollBar.prototype.constructor = ScrollBar;\r\nmodule.exports = ScrollBar;\r\n\r\nScrollBar.prototype.minThumbWidth = 20;\r\nScrollBar.prototype.minThumbHeight = 20;\r\n\r\nScrollBar.SKIN_NAME = 'scroll_bar';\r\n\r\nScrollBar.prototype.scrollableredraw = Scrollable.prototype.redraw;\r\n/**\r\n * recalculate scroll thumb width/height\r\n * @method redraw\r\n */\r\nScrollBar.prototype.redraw = function() {\r\n    if (this.invalidTrack) {\r\n        if (this.scrollArea && this.thumb) {\r\n            if (this.direction === Scrollable.HORIZONTAL) {\r\n                this.thumb.width = Math.max(this.minThumbWidth,\r\n                    this.scrollArea.width /\r\n                    (this.scrollArea.content.width / this.scrollArea.width));\r\n            } else {\r\n                this.thumb.height = Math.max(this.minThumbHeight,\r\n                    this.scrollArea.height /\r\n                    (this.scrollArea.content.height / this.scrollArea.height));\r\n            }\r\n        }\r\n        this.scrollableredraw(this);\r\n    }\r\n};\r\n\r\n/**\r\n * thumb has been moved - scroll content to position\r\n * @param x x-position to scroll to (ignored when vertical)\r\n * @param y y-position to scroll to (ignored when horizontal)\r\n * @method thumbMoved\r\n */\r\nScrollBar.prototype.thumbMoved = function(x, y) {\r\n    if (this.scrollArea && this.scrollArea.content) {\r\n\r\n        if (this._direction === Scrollable.HORIZONTAL) {\r\n            this.scrollArea._scrollContent(\r\n                -(this.scrollArea.content.width - this.scrollArea.width) *\r\n                    (x / (this.scrollArea.width - this.thumb.width)),\r\n                0);\r\n        } else {\r\n            this.scrollArea._scrollContent(\r\n                0,\r\n                -(this.scrollArea.content.height - this.scrollArea.height) *\r\n                    (y / (this.scrollArea.height - this.thumb.height)));\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Determines if the scroll bar's thumb can be dragged horizontally or\r\n * vertically.\r\n *\r\n * @property direction\r\n * @type String\r\n */\r\nObject.defineProperty(ScrollBar.prototype, 'direction', {\r\n    get: function() {\r\n        return this._direction;\r\n    },\r\n    set: function(direction) {\r\n        this._direction = direction;\r\n        this.invalid = true;\r\n    }\r\n});\r\n\r\n/**\r\n * value of the scrollbar\r\n * TODO: put in Scrollable\r\n *\r\n * @property value\r\n * @type Number\r\n */\r\nObject.defineProperty(ScrollBar.prototype, 'value', {\r\n    get: function() {\r\n        return this._value;\r\n    },\r\n    set: function(value) {\r\n        this._value = value;\r\n    }\r\n});\r\n","var Scroller = require('./Scroller');\r\n//var ScrollBar = require('./ScrollBar');\r\n\r\n/**\r\n * @class ScrollContainer\r\n * @extends GOWN.Scroller\r\n * @memberof GOWN\r\n * @constructor\r\n */\r\nfunction ScrollContainer(theme) {\r\n    Scroller.call(this, theme);\r\n}\r\n\r\nScrollContainer.prototype = Object.create( Scroller.prototype );\r\nScrollContainer.prototype.constructor = ScrollContainer;\r\nmodule.exports = ScrollContainer;\r\n","","var Button = require('./Button');\r\n\r\n/**\r\n * thumb button that can be moved on the scrollbar\r\n *\r\n * @class ScrollThumb\r\n * @extends GOWN.Button\r\n * @memberof GOWN\r\n * @constructor\r\n */\r\nfunction ScrollThumb(scrollable, theme, skinName) {\r\n    this.scrollable = scrollable;\r\n    var defaultSkin = ScrollThumb.SKIN_NAME;\r\n    if (!theme.thumbSkin) {\r\n        defaultSkin = Button.SKIN_NAME;\r\n    }\r\n    this.skinName = skinName || defaultSkin;\r\n    if (theme.thumbSkin) {\r\n        this._validStates = ScrollThumb.THUMB_STATES;\r\n    }\r\n    if (theme.thumbWidth) {\r\n        this.width = theme.thumbWidth;\r\n    }\r\n    if (theme.thumbHeight) {\r\n        this.height = theme.thumbHeight;\r\n    }\r\n    Button.call(this, theme, this.skinName);\r\n    this.invalidTrack = true;\r\n\r\n    this.touchmove = this.mousemove;\r\n    /* jshint unused: false */\r\n    this.touchdown = this.mousedown;\r\n    /* jshint unused: false */\r\n    this.touchend = this.touchendoutside = this.mouseup;\r\n}\r\n\r\nScrollThumb.prototype = Object.create( Button.prototype );\r\nScrollThumb.prototype.constructor = ScrollThumb;\r\nmodule.exports = ScrollThumb;\r\n\r\n\r\nScrollThumb.SKIN_NAME = 'scroll_thumb';\r\n\r\nScrollThumb.THUMB_STATES = [\r\n    'horizontal_up', 'vertical_up',\r\n    'horizontal_down', 'vertical_down',\r\n    'horizontal_hover', 'vertical_hover'\r\n];\r\n\r\nvar originalCurrentState = Object.getOwnPropertyDescriptor(Button.prototype, 'currentState');\r\n\r\n/**\r\n * The current state (one of _validStates)\r\n *\r\n * @property currentState\r\n * @type String\r\n */\r\nObject.defineProperty(ScrollThumb.prototype, 'currentState',{\r\n    set: function(value) {\r\n        if (this.theme.thumbSkin) {\r\n            // use skin including direction instead of default skin\r\n            value = this.scrollable.direction + '_' + value;\r\n        }\r\n        originalCurrentState.set.call(this, value);\r\n    }\r\n});\r\n\r\nScrollThumb.prototype.buttonmousedown = Button.prototype.mousedown;\r\nScrollThumb.prototype.mousedown = function(mouseData) {\r\n    this.buttonmousedown(mouseData);\r\n    var local = mouseData.data.getLocalPosition(this.scrollable);\r\n    this.scrollable._start = [local.x, local.y];\r\n    //this.scrollable.handleDown(mouseData);\r\n    mouseData.stopPropagation();\r\n};\r\n\r\nScrollThumb.prototype.buttonmousemove = Button.prototype.mousemove;\r\nScrollThumb.prototype.mousemove = function (mouseData) {\r\n    this.buttonmousemove(mouseData);\r\n    this.scrollable.handleMove(mouseData);\r\n};\r\n\r\nScrollThumb.prototype.buttonmouseup = Button.prototype.mouseup;\r\nScrollThumb.prototype.mouseup = function (mouseData) {\r\n    this.buttonmouseup(mouseData);\r\n    this.scrollable.handleUp();\r\n};\r\n\r\n/**\r\n * show track icon on thumb\r\n *\r\n * @method showTrack\r\n * @param skin\r\n */\r\nScrollThumb.prototype.showTrack = function(skin) {\r\n    if (this.skin !== skin) {\r\n        if(this.skin) {\r\n            this.removeChild(this.skin);\r\n        }\r\n\r\n        this.addChild(skin);\r\n        this.skin = skin;\r\n    }\r\n    skin.x = Math.floor((this.width - skin.getBounds().width )/ 2);\r\n    skin.y = Math.floor((this.height - skin.getBounds().height )/ 2);\r\n    this.invalidTrack = false;\r\n};\r\n\r\n/**\r\n * redraw the skin\r\n *\r\n * @method redraw\r\n */\r\nScrollThumb.prototype.redraw = function() {\r\n    this.redrawSkinable();\r\n    if (this.invalidTrack && this.theme.thumbSkin) {\r\n        this.fromSkin(this.scrollable.direction+'_thumb', this.showTrack);\r\n    }\r\n};\r\n\r\n\r\n/**\r\n * move the thumb on the scroll bar within its bounds\r\n *\r\n * @param x new calculated x position of the thumb\r\n * @param y new calculated y position of the thumb\r\n * @returns {boolean} returns true if the position of the thumb has been\r\n * moved\r\n * @method move\r\n */\r\nScrollThumb.prototype.move = function(x, y) {\r\n    if (this.scrollable.direction === GOWN.Scrollable.HORIZONTAL) {\r\n        if (isNaN(x)) {\r\n            return false;\r\n        }\r\n        x = Math.min(x, this.scrollable.maxWidth());\r\n        x = Math.max(x, 0);\r\n        if (x !== this.x) {\r\n            this.x = x;\r\n            return true;\r\n        }\r\n    } else {\r\n        if (isNaN(y)) {\r\n            return false;\r\n        }\r\n        y = Math.min(y, this.scrollable.maxHeight());\r\n        y = Math.max(y, 0);\r\n        if (y !== this.y) {\r\n            this.y = y;\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n};\r\n","var Skinable = require('../core/Skinable'),\r\n    ScrollThumb = require('./ScrollThumb'),\r\n    SliderData = require('../utils/SliderData');\r\n\r\n/**\r\n * a scrollabe control provides a thumb that can be be moved along a fixed track.\r\n * This is the common ground for ScrollBar and Slider\r\n *\r\n * @class Scrollable\r\n * @extends GOWN.Scrollable\r\n * @memberof GOWN\r\n * @constructor\r\n */\r\nfunction Scrollable(theme) {\r\n    this.mode = this.mode || Scrollable.DESKTOP_MODE;\r\n\r\n    Skinable.call(this, theme);\r\n\r\n    this.direction = this.direction || Scrollable.HORIZONTAL;\r\n\r\n    this.invalidTrack = true;\r\n    this._inverse = false;\r\n    this._start = null;\r\n    this._minimum = this._minimum || 0;\r\n    this._maximum = this._maximum || 100;\r\n    this.step = this.step || 1; //TODO: implement me!\r\n    this.page = this.page || 10; //TODO: implement me!\r\n    this._value = this.minimum;\r\n\r\n    // # of pixel you scroll at a time (if the event delta is 1 / -1)\r\n    this.scrolldelta = 10;\r\n\r\n    this.touchstart = this.mousedown = this.handleDown;\r\n    this.touchendoutside = this.touchend = this.mouseup = this.mouseupoutside = this.handleUp;\r\n\r\n    this.thumbFactoryInvalid = true;\r\n}\r\n\r\nScrollable.prototype = Object.create( Skinable.prototype );\r\nScrollable.prototype.constructor = Scrollable;\r\nmodule.exports = Scrollable;\r\n\r\n\r\n/**\r\n * in desktop mode mouse wheel support is added (default)\r\n *\r\n * @property DESKTOP_MODE\r\n * @static\r\n */\r\nScrollable.DESKTOP_MODE = 'desktop';\r\n\r\n/**\r\n * in mobile mode mouse wheel support is disabled\r\n *\r\n * @property MOBILE_MODE\r\n * @static\r\n */\r\nScrollable.MOBILE_MODE = 'mobile';\r\n\r\n/**\r\n * show horizontal scrollbar/slider\r\n *\r\n * @property HORIZONTAL\r\n * @static\r\n */\r\nScrollable.HORIZONTAL = 'horizontal';\r\n\r\n/**\r\n * show vertical scrollbar/slider\r\n *\r\n * @property VERTICAL\r\n * @static\r\n */\r\nScrollable.VERTICAL = 'vertical';\r\n\r\nScrollable.prototype.createThumb = function() {\r\n    this._thumbFactory = this._thumbFactory || this.defaultThumbFactory;\r\n    this.thumb = this._thumbFactory();\r\n    this.addChild(this.thumb);\r\n};\r\n\r\nScrollable.prototype.defaultThumbFactory = function() {\r\n    return new ScrollThumb(this, this.theme);\r\n};\r\n\r\n/**\r\n * handle mouse down/touch start\r\n * move scroll thumb clicking somewhere on the scroll bar (outside the thumb)\r\n *\r\n * @method handleDown\r\n * @param mouseData mousedata provided by pixi\r\n */\r\nScrollable.prototype.handleDown = function(mouseData) {\r\n    var local = mouseData.data.getLocalPosition(this);\r\n    var center = {\r\n        x: local.x - this.thumb.width / 2,\r\n        y: local.y - this.thumb.height / 2\r\n    };\r\n    if (mouseData.target === this &&\r\n        this.moveThumb(center.x, center.y)) {\r\n        this._start = [local.x, local.y];\r\n        this.thumbMoved(center.x, center.y);\r\n    }\r\n};\r\n\r\n/**\r\n * @private\r\n */\r\nScrollable.prototype.decrement = function() {\r\n  this.value -= this._step;\r\n};\r\n\r\n/**\r\n * @private\r\n */\r\nScrollable.prototype.increment = function() {\r\n  this.value += this._step;\r\n};\r\n\r\n/**\r\n * handle mouse up/touch end\r\n *\r\n * @method handleUp\r\n */\r\nScrollable.prototype.handleUp = function() {\r\n    this._start = null;\r\n};\r\n\r\n/**\r\n * handle mouse move: move thumb\r\n *\r\n * @method handleMove\r\n * @param mouseData mousedata provided by pixi\r\n */\r\nScrollable.prototype.handleMove = function(mouseData) {\r\n    if (this._start) {\r\n        var local = mouseData.data.getLocalPosition(this);\r\n        var x = this.thumb.x + local.x - this._start[0];\r\n        var y = this.thumb.y + local.y - this._start[1];\r\n        if (this.moveThumb(x, y)) {\r\n            // do not override localX/localY in start\r\n            // if we do not move the thumb\r\n            this.thumbMoved(x, y);\r\n            this._start[0] = local.x;\r\n            this._start[1] = local.y;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * handle mouse wheel: move thumb on track\r\n *\r\n * @method handleWheel\r\n * @param event mousewheel event from browser\r\n */\r\nScrollable.prototype.handleWheel = function (event) {\r\n    var x = this.thumb.x - event.delta * this.scrolldelta;\r\n    var y = this.thumb.y - event.delta * this.scrolldelta;\r\n    if (this.moveThumb(x, y)) {\r\n        this.thumbMoved(x, y);\r\n    }\r\n};\r\n\r\n/**\r\n * thumb has new x/y position\r\n *\r\n * @method thumbMoved\r\n * @param x x-position that has been scrolled to (ignored when vertical)\r\n * @param y y-position that has been scrolled to (ignored when horizontal)\r\n */\r\n/* jshint unused: false */\r\nScrollable.prototype.thumbMoved = function(x, y) {\r\n};\r\n\r\n/**\r\n * show the progress skin from the start/end of the scroll track to the current\r\n * position of the thumb.\r\n *\r\n * @method _updateProgressSkin\r\n * @private\r\n */\r\nScrollable.prototype._updateProgressSkin = function() {\r\n    if (!this.progressSkin) {\r\n        return;\r\n    }\r\n    if(this.direction === Scrollable.HORIZONTAL) {\r\n        var progressPosX = this.thumb.x + this.thumb.width / 2;\r\n        if (this.inverse) {\r\n            this.progressSkin.x = progressPosX;\r\n            this.progressSkin.width = this.width - progressPosX;\r\n            this.progressSkin.height = this.skin.height;\r\n        } else {\r\n            this.progressSkin.x = 0;\r\n            this.progressSkin.width = progressPosX;\r\n            this.progressSkin.height = this.skin.height;\r\n        }\r\n        // 2 px is the default in the Aeon-Theme.\r\n        // TODO: make this theme configurable?!\r\n        this.progressSkin.y = 2;\r\n        this.progressSkin.height -= this.progressSkin.y*2;\r\n    } else {\r\n        var progressPosY = this.thumb.y + this.thumb.height / 2;\r\n        if (this.inverse) {\r\n            this.progressSkin.y = progressPosY;\r\n            this.progressSkin.height = this.height - progressPosY;\r\n            this.progressSkin.width = this.skin.width;\r\n        } else {\r\n            this.progressSkin.y = 0;\r\n            this.progressSkin.height =progressPosY;\r\n            this.progressSkin.width = this.skin.width;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * returns the max. width in pixel\r\n * (normally this.width - thumb width)\r\n *\r\n * @method maxWidth\r\n * @returns {Number}\r\n */\r\nScrollable.prototype.maxWidth = function() {\r\n    return this.width - this.thumb.width;\r\n};\r\n\r\n/**\r\n * returns the max. height in pixel\r\n * (normally this.height - thumb height)\r\n *\r\n * @method maxHeight\r\n * @returns {Number}\r\n */\r\nScrollable.prototype.maxHeight = function() {\r\n    return this.height - this.thumb.height;\r\n};\r\n\r\n/**\r\n * move the thumb on the scroll bar within its bounds\r\n *\r\n * @param x new calculated x position of the thumb\r\n * @param y new calculated y position of the thumb\r\n * @returns {boolean} returns true if the position of the thumb has been\r\n * moved\r\n * @method moveThumb\r\n */\r\nScrollable.prototype.moveThumb = function(x, y) {\r\n    if (this.thumb.move(x, y)) {\r\n        this._updateProgressSkin();\r\n        return true;\r\n    }\r\n    return false;\r\n};\r\n\r\n/**\r\n * show scroll track\r\n *\r\n * @method showTrack\r\n * @param skin\r\n */\r\nScrollable.prototype.showTrack = function(skin) {\r\n    if (this.skin !== skin) {\r\n        if(this.skin) {\r\n            this.removeChild(this.skin);\r\n        }\r\n\r\n        this.addChildAt(skin, 0);\r\n        this.skin = skin;\r\n        if (this.progressSkin) {\r\n            this._updateProgressSkin();\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * show progress on track (from the start/end of the track to the\r\n * current position of the thumb)\r\n *\r\n * @method showProgress\r\n * @param skin\r\n */\r\nScrollable.prototype.showProgress = function(skin) {\r\n    if (this.progressSkin !== skin) {\r\n        if(this.progressSkin) {\r\n            this.removeChild(this.progressSkin);\r\n        }\r\n        skin.width = skin.height = 0;\r\n        this.addChildAt(skin, 0);\r\n        this.progressSkin = skin;\r\n        if (this.skin) {\r\n            this._updateProgressSkin();\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * redraw track and progressbar\r\n *\r\n * @method redraw\r\n */\r\nScrollable.prototype.redraw = function() {\r\n    if (this.thumbFactoryInvalid) {\r\n        this.createThumb();\r\n        this.thumbFactoryInvalid = false;\r\n    }\r\n    if (this.invalidTrack) {\r\n        this.fromSkin(this.direction+'_progress', this.showProgress);\r\n        this.fromSkin(this.direction+'_track', this.showTrack);\r\n        if (this.skin) {\r\n            if (this.direction === Scrollable.HORIZONTAL) {\r\n                this.skin.width = this.width;\r\n            } else {\r\n                this.skin.height = this.height;\r\n            }\r\n            this.invalidTrack = false;\r\n        }\r\n    }\r\n};\r\n\r\n\r\n/**\r\n * The width of the Scrollable, setting this will redraw the track and thumb.\r\n\r\n *\r\n * @property width\r\n * @type Number\r\n */\r\nObject.defineProperty(Scrollable.prototype, 'width', {\r\n    get: function() {\r\n        return this._width;\r\n    },\r\n    set: function(width) {\r\n        this._width = width;\r\n        this.invalidTrack = true;\r\n        if (this.thumb) {\r\n            this.thumb.invalidTrack = true;\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Inverse the progress bar\r\n *\r\n * @property inverse\r\n * @type Boolean\r\n */\r\nObject.defineProperty(Scrollable.prototype, 'inverse', {\r\n    get: function() {\r\n        return this._inverse;\r\n    },\r\n    set: function(inverse) {\r\n        if (inverse !== this._inverse) {\r\n            this._inverse = inverse;\r\n\r\n            if (this.direction === Scrollable.HORIZONTAL) {\r\n                this.moveThumb(0, this.width - this.thumb.x);\r\n            } else {\r\n                this.moveThumb(0, this.height - this.thumb.y);\r\n            }\r\n\r\n            this.invalidTrack = true;\r\n            if (this.thumb) {\r\n                this.thumb.invalidTrack = true;\r\n            }\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * The height of the Scrollable, setting this will redraw the track and thumb.\r\n *\r\n * @property height\r\n * @type Number\r\n */\r\nObject.defineProperty(Scrollable.prototype, 'height', {\r\n    get: function() {\r\n        return this._height;\r\n    },\r\n    set: function(height) {\r\n        this._height = height;\r\n        this.invalidTrack = true;\r\n        if (this.thumb) {\r\n            this.thumb.invalidTrack = true;\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * set value (between minimum and maximum)\r\n *\r\n * @property value\r\n * @type Number\r\n * @default 0\r\n */\r\nObject.defineProperty(Scrollable.prototype, 'value', {\r\n    get: function() {\r\n        return this._value;\r\n    },\r\n    set: function(value) {\r\n        if (isNaN(value)) {\r\n            return;\r\n        }\r\n        value = Math.min(value, this.maximum);\r\n        value = Math.max(value, this.minimum);\r\n        if (this._value === value) {\r\n            return;\r\n        }\r\n\r\n        this.emit('change', value, this);\r\n        // move thumb\r\n        if (this.thumb) {\r\n            var pos = this.valueToLocation(value);\r\n            if (this.direction === Scrollable.HORIZONTAL) {\r\n                this.moveThumb(pos, 0);\r\n            } else {\r\n                this.moveThumb(0, pos);\r\n            }\r\n        }\r\n\r\n        this._value = value;\r\n        if (this.change) {\r\n            var sliderData = new SliderData();\r\n            sliderData.value = this._value;\r\n            sliderData.target = this;\r\n            this.change(sliderData);\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * set minimum and update value if necessary\r\n *\r\n * @property minimum\r\n * @type Number\r\n * @default 0\r\n */\r\nObject.defineProperty(Scrollable.prototype, 'minimum', {\r\n    get: function() {\r\n        return this._minimum;\r\n    },\r\n    set: function(minimum) {\r\n        if(!isNaN(minimum) && this.minimum !== minimum && minimum < this.maximum) {\r\n            this._minimum = minimum;\r\n        }\r\n        if (this._value < this.minimum) {\r\n            this.value = this._value;\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * set maximum and update value if necessary\r\n *\r\n * @property maximum\r\n * @type Number\r\n * @default 100\r\n */\r\nObject.defineProperty(Scrollable.prototype, 'maximum', {\r\n    get: function() {\r\n        return this._maximum;\r\n    },\r\n    set: function(maximum) {\r\n        if(!isNaN(maximum) && this.maximum !== maximum && maximum > this.minimum) {\r\n            this._maximum = maximum;\r\n        }\r\n        if (this._value > this.maximum) {\r\n            this.value = maximum;\r\n        }\r\n    }\r\n});\r\n","var ScrollBar = require('./ScrollBar');\r\nvar Control = require('../core/Control');\r\nvar Scrollable = require('./Scrollable');\r\n\r\n/**\r\n * Allows horizontal and vertical scrolling of a view port.\r\n * Not meant to be used as a standalone container or component.\r\n * Generally meant to be the super class of another component that needs to\r\n * support scrolling.\r\n * To put components in a generic scrollable container (with optional layout),\r\n * see ScrollContainer. To scroll long passages of text, see ScrollText.\r\n *\r\n * @class Scroller\r\n * @extends GOWN.Control\r\n * @memberof GOWN\r\n * @constructor\r\n */\r\nfunction Scroller(theme) {\r\n    Control.call(this);\r\n    this.setTheme(theme);\r\n    this.interactive = true;\r\n    this.sizeValid = true;\r\n    this._clipContent = true;\r\n    this._horizontalScrollBarFactory = this.defaultScrollBarFactory;\r\n    this._verticalScrollBarFactory = this.defaultScrollBarFactory;\r\n    this.createScrollBars();\r\n}\r\n\r\nScroller.prototype = Object.create( Control.prototype );\r\nScroller.prototype.constructor = Scroller;\r\nmodule.exports = Scroller;\r\n\r\n/**\r\n * The scroller may scroll if the view port is larger than the\r\n * scroller's bounds. Only than the scroll bar will be visible.\r\n */\r\nScroller.SCROLL_POLICY_AUTO = 'auto';\r\n\r\n/**\r\n * The scroller will always scroll, the scroll bar will always be visible.\r\n */\r\nScroller.SCROLL_POLICY_ON = 'on';\r\n\r\n/**\r\n * The scroller does not scroll at all, the scroll bar will never be visible.\r\n */\r\nScroller.SCROLL_POLICY_OFF = 'off';\r\n\r\n/**\r\n * us a mask to clip content\r\n */\r\nObject.defineProperty(Scroller.prototype, 'clipContent', {\r\n    get: function() {\r\n        return this._clipContent;\r\n    },\r\n    set: function(value) {\r\n        if (this._clipContent === value) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis._clipContent = value;\r\n    }\r\n});\r\n\r\nObject.defineProperty(Scroller.prototype, 'viewPort', {\r\n    get: function() {\r\n        return this._viewPort;\r\n    },\r\n    set: function(value) {\r\n        if (this._viewPort === value) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif(this._viewPort) {\r\n\t\t\t//TODO: this._viewPort.off(FeathersEventType.RESIZE, viewPort_resizeHandler);\r\n            this.removeChild(this._viewPort);\r\n\t\t}\r\n\t\tthis._viewPort = value;\r\n\t\tif(this._viewPort) {\r\n\t\t\t//TODO: this._viewPort.addEventListener(FeathersEventType.RESIZE, viewPort_resizeHandler);\r\n            this.addChildAt(this._viewPort, 0);\r\n\t\t}\r\n\t\t//this.invalidate(Control.INVALIDATION_FLAG_SIZE);\r\n        this.sizeValid = false;\r\n    }\r\n});\r\n\r\n// performance increase to avoid using call.. (10x faster)\r\nScroller.prototype.controlRedraw = Control.prototype.redraw;\r\n/**\r\n * update before draw call\r\n *\r\n * @method redraw\r\n */\r\nScroller.prototype.redraw = function() {\r\n    if(this.clippingInvalid) {\r\n\t\tthis.refreshClipRect();\r\n\t}\r\n\r\n    if (this._viewPort.updateRenderable) {\r\n        this._viewPort.updateRenderable(\r\n            -this._viewPort.x, -this._viewPort.y,\r\n            this.width, this.height);\r\n    }\r\n    this.controlRedraw();\r\n};\r\n\r\nScroller.prototype.refreshClipRect = function() {\r\n    if (this.height && this.width && this._clipContent) {\r\n        if (this.clipRect === undefined) {\r\n            this.clipRect = new PIXI.Graphics();\r\n        }\r\n        //TODO: for scaling save scrollPosition!\r\n        //TODO this.clipRect.x = this._horizontalScrollPosition;\r\n        //TODO this.clipRect.y = this._verticalScrollPosition;\r\n\r\n        // update clipRectDimensions in own draw-function\r\n        this.drawClipRect();\r\n    } else {\r\n        if (this.clipRect) {\r\n            this.clipRect.clear();\r\n        }\r\n        this.clipRect = undefined;\r\n    }\r\n\r\n    this.clippingInvalid = false;\r\n};\r\n\r\n\r\n/**\r\n * draw mask (can be overwritten, e.g. to show something above the\r\n * scroll area when using a vertical layout)\r\n * @private\r\n * @method drawMask\r\n */\r\nScroller.prototype.drawClipRect = function() {\r\n    var pos = new PIXI.Point(0, 0);\r\n    var global = this.toGlobal(pos);\r\n\r\n    // TODO: viewportOffsets for width/height\r\n    // (see Scroller.as refreshClipRect)\r\n    //var clipWidth:Number = this.actualWidth - this._leftViewPortOffset - this._rightViewPortOffset;\r\n\r\n    this.clipRect.clear()\r\n        .beginFill('#fff', 1)\r\n        .drawRect(global.x, global.y, this.width, this.height)\r\n        .endFill();\r\n    this.mask = this.clipRect;\r\n    if (this.hitArea) {\r\n        this.hitArea.width = this.width;\r\n        this.hitArea.height = this.height;\r\n    } else {\r\n        this.hitArea = new PIXI.Rectangle(0, 0, this.width, this.height);\r\n    }\r\n};\r\n\r\n\r\n/**\r\n * Creates and adds the <code>horizontalScrollBar</code> and\r\n * <code>verticalScrollBar</code> sub-components and removes the old\r\n * instances, if they exist.\r\n *\r\n * <p>Meant for internal use, and subclasses may override this function\r\n * with a custom implementation.</p>\r\n *\r\n * @see #horizontalScrollBar\r\n * @see #verticalScrollBar\r\n * @see #horizontalScrollBarFactory\r\n * @see #verticalScrollBarFactory\r\n */\r\nScroller.prototype.createScrollBars = function() {\r\n    this.horizontalScrollBar = this._horizontalScrollBarFactory(Scrollable.HORIZONTAL);\r\n    this.verticalScrollBar = this._verticalScrollBarFactory(Scrollable.VERTICAL);\r\n};\r\n\r\nScroller.prototype.defaultScrollBarFactory = function(direction) {\r\n    return new ScrollBar(direction, this.theme);\r\n};\r\n\r\n\r\nScroller.prototype.revealHorizontalScrollBar = function() {\r\n    //TODO: implement me!\r\n};\r\n\r\nScroller.prototype.revealVerticalScrollBar = function() {\r\n    //TODO: implement me!\r\n};\r\n\r\n/**\r\n * The width of the Scroller (defines the viewport)\r\n *\r\n * @property width\r\n * @type Number\r\n */\r\nObject.defineProperty(Scroller.prototype, 'width', {\r\n    get: function() {\r\n        if (!this._width) {\r\n            return this._viewPort.width;\r\n        }\r\n        return this._width;\r\n    },\r\n    set: function(width) {\r\n        this._width = width;\r\n        this.clippingInvalid = true;\r\n    }\r\n});\r\n\r\n/**\r\n * The height of the Scroller (defines the viewport)\r\n *\r\n * @property height\r\n * @type Number\r\n */\r\nObject.defineProperty(Scroller.prototype, 'height', {\r\n    get: function() {\r\n        if (!this._height) {\r\n            return this._viewPort.height;\r\n        }\r\n        return this._height;\r\n    },\r\n    set: function(height) {\r\n        this._height = height;\r\n        this.clippingInvalid = true;\r\n    }\r\n});\r\n\r\n// TODO: elastic scrollSteps pageIndex updateVerticalScrollFromTouchPosition throwTo hideHorizontalScrollBar revealHorizontalScrollBar\r\n","var Scrollable = require('./Scrollable'),\r\n    SliderData = require('../utils/SliderData');\r\n\r\n/**\r\n * Simple slider with min. and max. value\r\n *\r\n * @class Slider\r\n * @extends GOWN.Scrollable\r\n * @memberof GOWN\r\n * @constructor\r\n */\r\n\r\nfunction Slider(thumb, theme, skinName) {\r\n    this.skinName = skinName || Slider.SKIN_NAME;\r\n\r\n    this._minimum = this._minimum || 0;\r\n    this._maximum = this._maximum || 100;\r\n    this.step = this.step || 0; //TODO: implement me!\r\n    this.page = this.page || 10; //TODO: implement me!\r\n    this._value = this.minimum;\r\n    this.change = null;\r\n\r\n    Scrollable.call(this, thumb, theme);\r\n}\r\n\r\nSlider.prototype = Object.create( Scrollable.prototype );\r\nSlider.prototype.constructor = Slider;\r\nmodule.exports = Slider;\r\n\r\n\r\nSlider.SKIN_NAME = 'scroll_bar';\r\n\r\n/**\r\n * thumb has been moved - calculate new value\r\n *\r\n * @param x x-position to scroll to (ignored when vertical)\r\n * @param y y-position to scroll to (ignored when horizontal)\r\n */\r\nSlider.prototype.thumbMoved = function(x, y) {\r\n    var pos = 0;\r\n    if (this.orientation === Scrollable.HORIZONTAL) {\r\n        pos = x;\r\n    } else {\r\n        pos = y;\r\n    }\r\n    this.value = this.pixelToValue(pos);\r\n};\r\n\r\n/**\r\n * calculate value of slider based on current pixel position of thumb\r\n *\r\n * @param position\r\n * @method pixelToValue\r\n * @returns Number value between minimum and maximum\r\n */\r\nSlider.prototype.pixelToValue = function(position) {\r\n    var max = 0;\r\n    if (this.orientation === Scrollable.HORIZONTAL) {\r\n        max = this.maxWidth();\r\n    } else {\r\n        max = this.maxHeight();\r\n    }\r\n    if (this._inverse) {\r\n        position = max - position;\r\n    }\r\n    return position / max * (this.maximum - this.minimum) + this.minimum;\r\n};\r\n\r\n/**\r\n * calculate current pixel position of thumb based on given value\r\n *\r\n * @param value\r\n * @method valueToPixel\r\n * @returns Number position of the scroll thumb in pixel\r\n */\r\nSlider.prototype.valueToPixel = function(value) {\r\n    var max = 0;\r\n    if (this.orientation === Scrollable.HORIZONTAL) {\r\n        max = this.maxWidth();\r\n    } else {\r\n        max = this.maxHeight();\r\n    }\r\n    var position = (value - this.minimum) / (this.maximum - this.minimum) * max;\r\n    if (this._inverse) {\r\n        position = max - position;\r\n    }\r\n    return position;\r\n};\r\n\r\n/**\r\n * set value (between minimum and maximum)\r\n *\r\n * @property value\r\n * @type Number\r\n * @default 0\r\n */\r\nObject.defineProperty(Slider.prototype, 'value', {\r\n    get: function() {\r\n        return this._value;\r\n    },\r\n    set: function(value) {\r\n        if (isNaN(value)) {\r\n            return;\r\n        }\r\n        value = Math.min(value, this.maximum);\r\n        value = Math.max(value, this.minimum);\r\n        if (this._value === value) {\r\n            return;\r\n        }\r\n\r\n        // move thumb\r\n        var pos = this.valueToPixel(value);\r\n        if (this.orientation === Scrollable.HORIZONTAL) {\r\n            this.moveThumb(pos, 0);\r\n        } else {\r\n            this.moveThumb(0, pos);\r\n        }\r\n\r\n        this._value = value;\r\n        if (this.change) {\r\n            var sliderData = new SliderData();\r\n            sliderData.value = this._value;\r\n            sliderData.target = this;\r\n            this.change(sliderData);\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * set minimum and update value if necessary\r\n *\r\n * @property minimum\r\n * @type Number\r\n * @default 0\r\n */\r\nObject.defineProperty(Slider.prototype, 'minimum', {\r\n    get: function() {\r\n        return this._minimum;\r\n    },\r\n    set: function(minimum) {\r\n        if(!isNaN(minimum) && this.minimum !== minimum && minimum < this.maximum) {\r\n            this._minimum = minimum;\r\n        }\r\n        if (this._value < this.minimum) {\r\n            this.value = this._value;\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * set maximum and update value if necessary\r\n *\r\n * @property maximum\r\n * @type Number\r\n * @default 100\r\n */\r\nObject.defineProperty(Slider.prototype, 'maximum', {\r\n    get: function() {\r\n        return this._maximum;\r\n    },\r\n    set: function(maximum) {\r\n        if(!isNaN(maximum) && this.maximum !== maximum && maximum > this.minimum) {\r\n            this._maximum = maximum;\r\n        }\r\n        if (this._value > this.maximum) {\r\n            this.value = maximum;\r\n        }\r\n    }\r\n});\r\n","var Control = require('../core/Control'),\r\n    InputControl = require('./InputControl'),\r\n    InputWrapper = require('../utils/InputWrapper');\r\n/**\r\n * The basic Text Input - based on PIXI.Input Input by Sebastian Nette,\r\n * see https://github.com/SebastianNette/PIXI.Input\r\n *\r\n * @class TextInput\r\n * @extends GOWN.InputControl\r\n * @memberof GOWN\r\n * @param text editable text shown in input\r\n * @param displayAsPassword Display TextInput as Password (default false)\r\n * @param theme default theme\r\n * @constructor\r\n */\r\n\r\nfunction TextInput(text, displayAsPassword, theme, skinName) {\r\n    // show and load background image as skin (exploiting skin states)\r\n    this.skinName = skinName || TextInput.SKIN_NAME;\r\n    this._validStates = this._validStates || TextInput.stateNames;\r\n    this._currentState = 'background';\r\n    this.invalidState = true;\r\n\r\n    InputControl.call(this, text, theme);\r\n\r\n    this._displayAsPassword = displayAsPassword || false;\r\n\r\n    /**\r\n     * timer used to indicate if the cursor is shown\r\n     *\r\n     * @property _cursorTimer\r\n     * @type {Number}\r\n     * @private\r\n     */\r\n    this._cursorTimer = 0;\r\n\r\n    /**\r\n     * indicates if the cursor position has changed\r\n     *\r\n     * @property _cursorNeedsUpdate\r\n     * @type {Boolean}\r\n     * @private\r\n     */\r\n\r\n    this._cursorNeedsUpdate = true;\r\n\r\n    /**\r\n     * interval for the cursor (in milliseconds)\r\n     *\r\n     * @property blinkInterval\r\n     * @type {number}\r\n     */\r\n    this.blinkInterval = 500;\r\n\r\n    /**\r\n     * selected area (start and end)\r\n     *\r\n     * @type {Array}\r\n     * @private\r\n     */\r\n    this.selection = [0, 0];\r\n\r\n    // caret/selection sprite\r\n    this.cursor = new PIXI.Text('|', this.theme.textStyle);\r\n    this.addChild(this.cursor);\r\n\r\n    // selection background\r\n    this.selectionBg = new PIXI.Graphics();\r\n    this.addChildAt(this.selectionBg, 0);\r\n\r\n    // set up events\r\n    this.boundOnMouseUp = this.onMouseUp.bind(this);\r\n    this.boundOnMouseUpOutside = this.onMouseUpOutside.bind(this);\r\n    this.boundOnMouseDown = this.onMouseDown.bind(this);\r\n    this.boundOnMouseMove = this.onMouseMove.bind(this);\r\n\r\n    this.mousemove = this.touchmove = this.boundOnMouseMove;\r\n    this.mousedown = this.touchstart = this.boundOnMouseDown;\r\n    this.mouseup = this.touchend = this.boundOnMouseUp;\r\n    this.mouseupoutside = this.touchendoutside = this.boundOnMouseUpOutside;\r\n}\r\n\r\nTextInput.prototype = Object.create(InputControl.prototype);\r\nTextInput.prototype.constructor = TextInput;\r\nmodule.exports = TextInput;\r\n\r\n\r\n// name of skin\r\nTextInput.SKIN_NAME = 'text_input';\r\n\r\n/**\r\n * set the text that is shown inside the input field.\r\n * calls onTextChange callback if text changes\r\n *\r\n * @property text\r\n * @type String\r\n */\r\nObject.defineProperty(TextInput.prototype, 'text', {\r\n    get: function () {\r\n        return this._text;\r\n    },\r\n    set: function (text) {\r\n        text += ''; // add '' to assure text is parsed as string\r\n        if (this._origText === text) {\r\n            // return if text has not changed\r\n            return;\r\n        }\r\n        this._origText = text;\r\n        if (this._displayAsPassword) {\r\n            text = text.replace(/./gi, '*');\r\n        }\r\n        this._text = text || '';\r\n        if (!this.pixiText) {\r\n            this.pixiText = new PIXI.Text(text, this.theme.textStyle);\r\n            this.addChild(this.pixiText);\r\n        } else {\r\n            this.pixiText.text = text;\r\n        }\r\n\r\n        // update text input if this text field has the focus\r\n        if (this.hasFocus) {\r\n            InputWrapper.setText(this.value);\r\n        }\r\n\r\n        // reposition cursor\r\n        this._cursorNeedsUpdate = true;\r\n    }\r\n});\r\n\r\n/**\r\n * The maximum number of characters that may be entered. If 0,\r\n * any number of characters may be entered.\r\n * (same as maxLength for DOM inputs)\r\n *\r\n * @default 0\r\n * @property maxChars\r\n * @type String\r\n */\r\nObject.defineProperty(TextInput.prototype, 'maxChars', {\r\n    get: function () {\r\n        return this._maxChars;\r\n    },\r\n    set: function (value) {\r\n        if (this._maxChars === value) {\r\n            return;\r\n        }\r\n        InputWrapper.setMaxLength(value);\r\n        this._maxChars = value;\r\n    }\r\n});\r\n\r\nObject.defineProperty(TextInput.prototype, 'value', {\r\n    get: function() {\r\n        return this._origText;\r\n    }\r\n});\r\n\r\n/**\r\n * set text and type of DOM text input\r\n *\r\n * @method onfocus\r\n */\r\nTextInput.prototype.onfocus = function() {\r\n    InputWrapper.setText(this.value);\r\n    InputWrapper.setMaxLength(this.maxChars);\r\n    if (this._displayAsPassword) {\r\n        InputWrapper.setType('password');\r\n    } else {\r\n        InputWrapper.setType('text');\r\n    }\r\n};\r\n\r\n/**\r\n * set selected text\r\n *\r\n * @method updateSelection\r\n * @param start\r\n * @param end\r\n * @returns {boolean}\r\n */\r\nTextInput.prototype.updateSelection = function (start, end) {\r\n    if (this.selection[0] !== start || this.selection[1] !== end) {\r\n        this.selection[0] = start;\r\n        this.selection[1] = end;\r\n        InputWrapper.setSelection(start, end);\r\n        this._cursorNeedsUpdate = true;\r\n        this.updateSelectionBg();\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n};\r\n\r\nTextInput.prototype.updateSelectionBg = function() {\r\n    var start = this.posToCoord(this.selection[0]),\r\n        end = this.posToCoord(this.selection[1]);\r\n\r\n    this.selectionBg.clear();\r\n    if (start !== end) {\r\n        this.selectionBg.beginFill(0x0080ff);\r\n        this.selectionBg.drawRect(0, 0, end - start, this.pixiText.height);\r\n        this.selectionBg.x = start;\r\n        this.selectionBg.y = this.pixiText.y;\r\n    }\r\n};\r\n\r\n\r\nTextInput.prototype.inputControlOnBlur = InputControl.prototype.onblur;\r\nTextInput.prototype.onblur = function() {\r\n    this.inputControlOnBlur();\r\n    this.updateSelection(0, 0);\r\n};\r\n\r\nTextInput.prototype.inputControlKeyDown = InputControl.prototype.onKeyDown;\r\nTextInput.prototype.onKeyDown = function () {\r\n    this.inputControlKeyDown();\r\n    // update the canvas input state information from the hidden input\r\n    this.updateTextState();\r\n};\r\n\r\nTextInput.prototype.inputControlKeyUp = InputControl.prototype.onKeyUp;\r\nTextInput.prototype.onKeyUp = function () {\r\n    this.updateTextState();\r\n    this.inputControlKeyUp();\r\n};\r\n\r\n/**\r\n * position cursor on the text\r\n */\r\nTextInput.prototype.setCursorPos = function () {\r\n    this.cursor.x = this.textWidth(this.text.substring(0, this.cursorPos)) | 0;\r\n};\r\n\r\n/**\r\n * draw the cursor\r\n *\r\n * @method drawCursor\r\n */\r\nTextInput.prototype.drawCursor = function () {\r\n    if (this.hasFocus || this._mouseDown) {\r\n        var time = Date.now();\r\n\r\n        // blink interval for cursor\r\n        if ((time - this._cursorTimer) >= this.blinkInterval) {\r\n            this._cursorTimer = time;\r\n            this.cursor.visible = !this.cursor.visible;\r\n        }\r\n\r\n        // update cursor position\r\n        if (this.cursor.visible && this._cursorNeedsUpdate) {\r\n            this.setCursorPos();\r\n            this._cursorNeedsUpdate = false;\r\n        }\r\n    } else {\r\n        this.cursor.visible = false;\r\n    }\r\n};\r\n\r\nTextInput.prototype.redraw = function () {\r\n    this.drawCursor();\r\n    Control.prototype.redraw.call(this);\r\n};\r\n\r\nTextInput.prototype.onMouseMove = function (e) {\r\n    var mouse = this.mousePos(e);\r\n    if (!this.hasFocus || !this._mouseDown || this.selectionStart < 0) { // || !this.containsPoint(mouse)) {\r\n        return false;\r\n    }\r\n\r\n    var curPos = this.clickPos(mouse.x, mouse.y),\r\n        start = Math.min(this.selectionStart, curPos),\r\n        end = Math.max(this.selectionStart, curPos);\r\n\r\n    if (this.updateSelection(start, end)) {\r\n        this.cursorPos = curPos;\r\n        this.setCursorPos();\r\n        this._cursorNeedsUpdate = true;\r\n    }\r\n    return true;\r\n};\r\n\r\nTextInput.prototype.onMouseDown = function (e) {\r\n    var originalEvent = e.data.originalEvent;\r\n    if (originalEvent.which === 2 || originalEvent.which === 3) {\r\n        originalEvent.preventDefault();\r\n        return false;\r\n    }\r\n\r\n    // focus input\r\n    this.focus();\r\n\r\n    this._mouseDown = true;\r\n    var mouse = this.mousePos(e);\r\n\r\n    // start the selection drag if inside the input\r\n    this.selectionStart = this.clickPos(mouse.x, mouse.y);\r\n    this.updateSelection(this.selectionStart, this.selectionStart);\r\n    this.cursorPos = this.selectionStart;\r\n    this.setCursorPos();\r\n    return true;\r\n};\r\n\r\nTextInput.prototype.onMouseUp = function (e) {\r\n    var originalEvent = e.data.originalEvent;\r\n    if (originalEvent.which === 2 || originalEvent.which === 3) {\r\n        originalEvent.preventDefault();\r\n        return false;\r\n    }\r\n\r\n    var mouse = this.mousePos(e);\r\n\r\n    // update selection if a drag has happened\r\n    var clickPos = this.clickPos(mouse.x, mouse.y);\r\n\r\n    // update the cursor position\r\n    if (!(this.selectionStart >= 0 && clickPos !== this.selectionStart)) {\r\n        this.cursorPos = clickPos;\r\n        this.setCursorPos();\r\n        this.updateSelection(this.cursorPos, this.cursorPos);\r\n    }\r\n\r\n    this.selectionStart = -1;\r\n    this._mouseDown = false;\r\n    return true;\r\n};\r\n\r\n/**\r\n * synchronize TextInput with DOM element\r\n *\r\n * @method updateTextState\r\n */\r\nTextInput.prototype.updateTextState = function () {\r\n    var text = InputWrapper.getText();\r\n\r\n    if (text !== this.text) {\r\n        this.text = text;\r\n    }\r\n\r\n    var sel = InputWrapper.getSelection();\r\n    if (this.updateSelection(sel[0], sel[1])) {\r\n        this.cursorPos = sel[0];\r\n    }\r\n    this.setCursorPos();\r\n};\r\n","var Button = require('./Button');\r\n\r\n/**\r\n * basic button that has a selected state which indicates if the button\r\n * is pressed or not.\r\n *\r\n * @class ToggleButton\r\n * @extends GOWN.Button\r\n * @memberof GOWN\r\n * @constructor\r\n */\r\nfunction ToggleButton(theme, skinName) {\r\n    skinName = skinName || ToggleButton.SKIN_NAME;\r\n    this._validStates = ToggleButton.stateNames;\r\n    Button.call(this, theme, skinName);\r\n\r\n    /**\r\n     * The pressed state of the Button\r\n     *\r\n     * @property selected\r\n     * @type Boolean\r\n     */\r\n    this._selected = false;\r\n}\r\n\r\nToggleButton.prototype = Object.create( Button.prototype );\r\nToggleButton.prototype.constructor = ToggleButton;\r\nmodule.exports = ToggleButton;\r\n\r\n/**\r\n * Dispatched when the button is selected or deselected either\r\n * programmatically or as a result of user interaction.The value of the\r\n * <code>selected</code> property indicates whether the button is selected.\r\n * or not.\r\n */\r\nToggleButton.CHANGE = 'change';\r\n\r\nToggleButton.SKIN_NAME = 'toggle_button';\r\n\r\nToggleButton.SELECTED_UP = 'selected_up';\r\nToggleButton.SELECTED_DOWN = 'selected_down';\r\nToggleButton.SELECTED_HOVER = 'selected_hover';\r\n\r\nToggleButton.stateNames = Button.stateNames.concat([\r\n    ToggleButton.SELECTED_UP,\r\n    ToggleButton.SELECTED_DOWN,\r\n    ToggleButton.SELECTED_HOVER]);\r\n\r\n\r\nvar originalCurrentState = Object.getOwnPropertyDescriptor(Button.prototype, 'currentState');\r\n\r\n/**\r\n * The current state (one of _validStates)\r\n *\r\n * @property currentState\r\n * @type String\r\n */\r\nObject.defineProperty(ToggleButton.prototype, 'currentState',{\r\n    set: function(value) {\r\n        if (this._selected) {\r\n            value = 'selected_' + value;\r\n        }\r\n        originalCurrentState.set.call(this, value);\r\n    }\r\n});\r\n\r\n/**\r\n * Indicate if the button is selected (pressed)\r\n *\r\n * @property selected\r\n * @type Boolean\r\n */\r\nObject.defineProperty(ToggleButton.prototype, 'selected', {\r\n    set: function(selected) {\r\n        var state = this._currentState;\r\n        this.invalidState = this._selected !== selected || this.invalidState;\r\n        if (state.indexOf('selected_') === 0) {\r\n            state = state.substr(9, state.length);\r\n        }\r\n        if (this._selected !== selected) {\r\n            this._selected = selected;\r\n            this.emit(ToggleButton.CHANGE, this, selected);\r\n        }\r\n        this._pressed = false; //to prevent toggling on touch/mouse up\r\n        this.currentState = state;\r\n    },\r\n    get: function() {\r\n        return this._selected;\r\n    }\r\n});\r\n\r\n/**\r\n * toggle state\r\n */\r\nToggleButton.prototype.toggle = function() {\r\n    this.selected = !this._selected;\r\n};\r\n\r\n\r\nToggleButton.prototype.buttonHandleEvent = Button.prototype.handleEvent;\r\n\r\n/**\r\n * handle Touch/Tab Event\r\n * @method handleEvent\r\n * @param {Object} type the type of the press/touch.\r\n * @protected\r\n **/\r\nToggleButton.prototype.handleEvent = function(type) {\r\n    if (!this._enabled) {\r\n        return;\r\n    }\r\n    var pressedBefore = this._pressed;\r\n    this.buttonHandleEvent(type);\r\n    if (type === Button.UP && this._over && pressedBefore) {\r\n        this.toggle();\r\n    }\r\n};\r\n","var ToggleButton = require('../ToggleButton');\r\nvar Button = require('../Button');\r\n\r\nfunction DefaultListItemRenderer(theme) {\r\n    //this._skinName = DefaultListItemRenderer.SKIN_NAME;\r\n    ToggleButton.call(this, theme);\r\n\r\n    /**\r\n     * A key in the item data that will be shown as label for the item.\r\n     * e.g. 'text' for item.text.\r\n     * will be ignored if labelFunction is set.\r\n     *\r\n     * the item will be shown directly (using toString) if\r\n     * labelField and labelFunction are not set.\r\n     *\r\n     * @default 'text'\r\n     */\r\n    this.labelField = 'text';\r\n\r\n    /**\r\n\t * A function used to generate label text for a specific item. If this\r\n\t * function is not null, then the <code>labelField</code> will be\r\n\t * ignored.\r\n\t *\r\n\t * <p>The function is expected to have the following signature:</p>\r\n\t * <pre>function( item )</pre> and return a string\r\n\t *\r\n\t * <p>In the following example, the label function is customized:</p>\r\n\t * renderer.labelFunction = function( item ) {\r\n\t *    return item.firstName + \" \" + item.lastName;\r\n\t * };</listing>\r\n\t *\r\n\t * @default null\r\n\t *\r\n\t * @see #labelField\r\n\t */\r\n    this.labelFunction = null;\r\n\r\n    this._data = null;\r\n    this.dataInvalid = false;\r\n}\r\n\r\nDefaultListItemRenderer.prototype = Object.create( ToggleButton.prototype );\r\nDefaultListItemRenderer.prototype.constructor = DefaultListItemRenderer;\r\nmodule.exports = DefaultListItemRenderer;\r\n\r\n//DefaultListItemRenderer.STYLE_NAME = \"default_item_renderer\";\r\n\r\n// performance increase to avoid using call.. (10x faster)\r\nDefaultListItemRenderer.prototype.redrawButton = Button.prototype.redraw;\r\n\r\n/**\r\n * update before draw call update button text\r\n *\r\n * @method redraw\r\n */\r\nDefaultListItemRenderer.prototype.redraw = function() {\r\n    if (this.dataInvalid) {\r\n        this.commitData();\r\n    }\r\n    this.redrawButton();\r\n};\r\n\r\nObject.defineProperty(DefaultListItemRenderer.prototype, 'data', {\r\n    set: function(data) {\r\n        this._data = data;\r\n        this.dataInvalid = true;\r\n    },\r\n    get: function() {\r\n        return this._data;\r\n    }\r\n});\r\n\r\n/**\r\n * Updates the renderer to display the item's data. Override this\r\n * function to pass data to sub-components and react to data changes.\r\n *\r\n * <p>Don't forget to handle the case where the data is <code>null</code>.</p>\r\n *\r\n * @method commitData\r\n */\r\nDefaultListItemRenderer.prototype.commitData = function() {\r\n    if(this._data) {\r\n        this.label = this.itemToLabel(this._data);\r\n    }\r\n    this.dataInvalid = false;\r\n};\r\n\r\n/**\r\n * Using <code>labelField</code> and <code>labelFunction</code>,\r\n * generates a label from the item.\r\n *\r\n * <p>All of the label fields and functions, ordered by priority:</p>\r\n * <ol>\r\n *     <li><code>labelFunction</code></li>\r\n *     <li><code>labelField</code></li>\r\n * </ol>\r\n *\r\n * @method itemToLabel\r\n */\r\nDefaultListItemRenderer.prototype.itemToLabel = function(item) {\r\n\tif (this.labelFunction) {\r\n\t\treturn this.labelFunction(item).toString();\r\n\t}\r\n\telse if (this.labelField && item && item.hasOwnProperty(this.labelField)) {\r\n\t\treturn item[this.labelField].toString();\r\n\t}\r\n\telse if(item) {\r\n\t\treturn item.toString();\r\n\t}\r\n\treturn '';\r\n};\r\n","/**\r\n * base for all UI controls (see controls/)\r\n * based on pixi-DisplayContainer that supports adding children, so all\r\n * controls are container\r\n * @class Control\r\n * @extends PIXI.Container\r\n * @memberof GOWN\r\n * @constructor\r\n */\r\nfunction Control() {\r\n    PIXI.Container.call(this);\r\n    this.enabled = this.enabled !== false;\r\n    // assume all controls are interactive\r\n    this.interactive = true;\r\n}\r\n\r\nControl.prototype = Object.create( PIXI.Container.prototype );\r\nControl.prototype.constructor = Control;\r\nmodule.exports = Control;\r\n\r\n/**\r\n * change the theme (every control can have a theme, even if it does not\r\n * inherit Skinable, e.g. if there is only some color in the skin that will\r\n * be taken or if it has some skinable components as children)\r\n *\r\n * @method setTheme\r\n * @param theme the new theme {Theme}\r\n */\r\nControl.prototype.setTheme = function(theme) {\r\n    if (theme === this.theme && theme) {\r\n        return;\r\n    }\r\n\r\n    this.theme = theme;\r\n    this.invalidSkin = true;\r\n};\r\n\r\nControl.prototype.updateTransformContainer = PIXI.Container.prototype.updateTransform;\r\n/**\r\n * PIXI method to update the object transform for rendering\r\n * Used to call redraw() before rendering\r\n *\r\n * @method updateTransform\r\n */\r\nControl.prototype.updateTransform = function() {\r\n    if (!this.parent) {\r\n        return;\r\n    }\r\n    if (this.redraw) {\r\n        this.redraw();\r\n    }\r\n    this.updateTransformContainer();\r\n};\r\n\r\n/**\r\n * get local mouse position from PIXI.InteractionData\r\n *\r\n * @method mousePos\r\n * @returns {PIXI.Point}\r\n */\r\nControl.prototype.mousePos = function(e) {\r\n    return e.data.getLocalPosition(this);\r\n};\r\n\r\n/**\r\n * update before draw call\r\n * redraw control for current state from theme\r\n *\r\n * @method redraw\r\n */\r\nControl.prototype.redraw = function() {\r\n};\r\n\r\n/**\r\n * Enables/Disables the control.\r\n * (not implemented yet)\r\n *\r\n * @property enabled\r\n * @type Boolean\r\n */\r\nObject.defineProperty(Control.prototype, 'enabled', {\r\n    get: function() {\r\n        return this._enabled;\r\n    },\r\n    set: function(value) {\r\n        this._enabled = value;\r\n    }\r\n});\r\n\r\n\r\n//var originalWidth = Object.getOwnPropertyDescriptor(PIXI.DisplayObjectContainer.prototype, 'width');\r\n\r\n/**\r\n * The width of the shape, setting this will redraw the component.\r\n * (set redraw)\r\n *\r\n * @property width\r\n * @type Number\r\n */\r\nObject.defineProperty(Control.prototype, 'width', {\r\n    get: function() {\r\n        return this._width;\r\n        //return originalWidth.get.call(this);\r\n    },\r\n    set: function(width) {\r\n        this._width = width;\r\n        //originalWidth.set.call(this, width);\r\n    }\r\n});\r\n\r\n//var originalHeight = Object.getOwnPropertyDescriptor(PIXI.DisplayObjectContainer.prototype, 'height');\r\n\r\n/**\r\n * The height of the shape, setting this will redraw the component.\r\n * (set redraw)\r\n *\r\n * @property height\r\n * @type Number\r\n */\r\nObject.defineProperty(Control.prototype, 'height', {\r\n    get: function() {\r\n        //return originalHeight.get.call(this);\r\n        return this._height;\r\n    },\r\n    set: function(height) {\r\n        //originalHeight.set.call(this, height);\r\n        this._height = height;\r\n    }\r\n});\r\n","var Control = require('./Control');\r\nvar resizeScaling = require('../utils/resizeScaling');\r\nvar mixin = require('../utils/mixin');\r\n\r\n/**\r\n * Control that requires a theme (e.g. a button)\r\n *\r\n * @class Skinable\r\n * @extends GOWN.Control\r\n * @memberof GOWN\r\n * @constructor\r\n */\r\nfunction Skinable(theme) {\r\n    Control.call(this);\r\n    this.skinCache = {};\r\n    this.setTheme(theme || GOWN.theme);\r\n\r\n    if (this.theme === undefined) {\r\n        throw new Error('you need to define a theme first');\r\n    }\r\n\r\n    // invalidate state so the control will be redrawn next time\r\n    this.invalidState = true; // draw for the first time\r\n\r\n    this.initResizeScaling();\r\n}\r\n\r\nSkinable.prototype = Object.create( Control.prototype );\r\nSkinable.prototype.constructor = Skinable;\r\nmodule.exports = Skinable;\r\n\r\nSkinable.prototype.controlSetTheme = Control.prototype.setTheme;\r\n/**\r\n * change the theme\r\n *\r\n * @method setTheme\r\n * @param theme the new theme {Theme}\r\n */\r\nSkinable.prototype.setTheme = function(theme) {\r\n    if (theme === this.theme && theme) {\r\n        return;\r\n    }\r\n\r\n    this.controlSetTheme(theme);\r\n    this.preloadSkins();\r\n    // force states to redraw\r\n    this.invalidState = true;\r\n};\r\n\r\n/**\r\n * remove old skin and add new one\r\n *\r\n * @method changeSkin\r\n * @param skin {DisplayObject}\r\n */\r\nSkinable.prototype.changeSkin = function(skin) {\r\n    if (this._currentSkin !== skin) {\r\n        this._lastSkin = this._currentSkin;\r\n        this.addChildAt(skin, 0);\r\n        skin.alpha = 1.0;\r\n        this._currentSkin = skin;\r\n\r\n    }\r\n    this.invalidState = false;\r\n};\r\n\r\n/**\r\n * initiate all skins first\r\n *\r\n * @method preloadSkins\r\n */\r\nSkinable.prototype.preloadSkins = function() {\r\n};\r\n\r\n/**\r\n * get image from skin (will execute a callback with the loaded skin\r\n * when it is loaded or call it directly when it already is loaded)\r\n *\r\n * @method fromSkin\r\n * @param name name of the state\r\n * @param callback callback that is executed if the skin is loaded\r\n */\r\nSkinable.prototype.fromSkin = function(name, callback) {\r\n    var skin;\r\n    if (this.skinCache[name]) {\r\n        skin = this.skinCache[name];\r\n    } else {\r\n        skin = this.theme.getSkin(this.skinName, name);\r\n        this.skinCache[name] = skin;\r\n    }\r\n    if (skin) {\r\n        callback.call(this, skin);\r\n    }\r\n};\r\n\r\n\r\nmixin(Skinable.prototype, resizeScaling);\r\n\r\n/**\r\n * change the skin name\r\n * You normally set the skin name as constant in your control, but if you\r\n * want you can set another skin name to change skins for single components\r\n * at runtime.\r\n *\r\n * @property skinName\r\n * @type String\r\n */\r\nObject.defineProperty(Skinable.prototype, 'skinName', {\r\n    get: function() {\r\n        return this._skinName;\r\n    },\r\n    set: function(value) {\r\n        if ( this._skinName === value ) {\r\n            return;\r\n        }\r\n        this._skinName = value;\r\n        this.invalidState = true;\r\n    }\r\n});\r\n","/**\r\n * @file        Main export of the gown.js core library\r\n * @author      Andreas Bresser <andreasbresser@gmail.com>\r\n * @copyright   2015 Andreas Bresser\r\n * @license     {@link https://github.com/brean/gown.js/blob/master/LICENSE|Apache License}\r\n */\r\n\r\n/**\r\n * @namespace GOWN.core\r\n */\r\nmodule.exports = {\r\n    Control:        require('./Control'),\r\n    Skinable:       require('./Skinable'),\r\n};\r\n","var EventEmitter = require('eventemitter3');\r\n\r\n/**\r\n * used to handle data manipulation (emit events when data changes so for\r\n *  example a List showing it can be updated and the user does not need to\r\n *  call a special update function every time he adds/removes data from the\r\n *  ListCollection.\r\n * use the ListCollection functions to manipulate the data-array OR modify it\r\n * using the default array-functions and dispatch the CHANGED-Event yourself.\r\n *\r\n * @class ListCollection\r\n * @extends GOWN.ListCollection\r\n * @memberof GOWN\r\n * @constructor\r\n */\r\nfunction ListCollection(data) {\r\n    if (!data) {\r\n        data = [];\r\n    }\r\n    this.data = data;\r\n}\r\nListCollection.prototype = Object.create( EventEmitter.prototype );\r\nListCollection.prototype.constructor = ListCollection;\r\nmodule.exports = ListCollection;\r\n\r\nListCollection.CHANGED = 'changed';\r\n\r\nListCollection.RESET = 'reset';\r\nListCollection.REMOVE_ITEM = 'removeItem';\r\nListCollection.REPLACE_ITEM = 'replaceItem';\r\nListCollection.ADD_ITEM = 'addItem';\r\n\r\n/**\r\n * The data source for this collection. Has to be an array.\r\n *\r\n * @property data\r\n * @type Object\r\n */\r\nObject.defineProperty(ListCollection.prototype, 'data', {\r\n    set: function(data) {\r\n        this._data = data;\r\n        this.emit(ListCollection.CHANGED);\r\n    },\r\n    get: function() {\r\n        return this._data;\r\n    }\r\n});\r\n\r\nObject.defineProperty(ListCollection.prototype, 'length', {\r\n    get: function() {\r\n        if (!this.data) {\r\n            return 0;\r\n        }\r\n        return this._data.length;\r\n    }\r\n});\r\n\r\nListCollection.prototype.getItemAt = function(index) {\r\n    return this._data[index];\r\n};\r\n\r\nListCollection.prototype.getItemIndex = function(item) {\r\n    return this._data.indexOf(item);\r\n};\r\n\r\n/**\r\n * add new item between index and index+1\r\n */\r\nListCollection.prototype.addItemAt = function(item, index) {\r\n    this._data.splice(index, 0, item);\r\n    this.emit(ListCollection.CHANGE, item);\r\n    this.emit(ListCollection.ADD_ITEM, item, index);\r\n};\r\n\r\n/**\r\n * Removes the item at the specified index from the collection and\r\n * returns it.\r\n */\r\nListCollection.prototype.removeItemAt = function (index) {\r\n    var item = this._data.splice(index, 1);\r\n    this.emit(ListCollection.CHANGE, item);\r\n    this.emit(ListCollection.REMOVE_ITEM, item, index);\r\n    return item;\r\n};\r\n\r\nListCollection.prototype.removeItem = function (item) {\r\n    var index = this.getItemIndex(item);\r\n    if (index >= 0) {\r\n\t\tthis.removeItemAt(index);\r\n\t}\r\n};\r\n\r\n\r\nListCollection.prototype.removeAll = function (item) {\r\n    if (this._data.length === 0) {\r\n        return;\r\n    }\r\n    this._data.length = 0;\r\n    this.emit(ListCollection.CHANGE, item);\r\n    this.emit(ListCollection.RESET);\r\n};\r\n\r\nListCollection.prototype.setItemAt = function (item, index) {\r\n    this._data[index] = item;\r\n    this.emit(ListCollection.CHANGE, item);\r\n    this.emit(ListCollection.REPLACE_ITEM, index, item);\r\n};\r\n\r\nListCollection.prototype.push = function (item) {\r\n    this._data.push(item);\r\n    this.emit(ListCollection.CHANGE, item);\r\n    this.emit(ListCollection.ADD_ITEM, item, this._data.length-1);\r\n};\r\n\r\nListCollection.prototype.pop = function () {\r\n    var item = this._data.pop();\r\n    this.emit(ListCollection.CHANGE, item);\r\n    this.emit(ListCollection.REMOVE_ITEM, item, this._data.length);\r\n};\r\n\r\nListCollection.prototype.unshift = function (item) {\r\n    this.addItemAt(item, 0);\r\n};\r\n\r\nListCollection.prototype.shift = function () {\r\n    this.removeItemAt(0);\r\n};\r\n\r\nListCollection.prototype.contains = function (item) {\r\n    return this.getItemIndex(item) >= 0;\r\n};\r\n","var ScaleContainer = require('../utils/ScaleContainer');\r\nvar ThemeFont = require('./ThemeFont');\r\nvar EventEmitter = require('eventemitter3');\r\n\r\n/**\r\n * basic theming/skinning.\r\n *\r\n * @class Theme\r\n * @memberof GOWN\r\n * @constructor\r\n */\r\nfunction Theme(global) {\r\n    EventEmitter.call(this);\r\n\r\n    // at its core a theme is just a dict that holds a collection of skins\r\n    this._skins = {};\r\n\r\n    // default font for labels (e.g. buttons)\r\n    if (this.textStyle) {\r\n        this.textStyle.clone();\r\n    } else {\r\n        this.textStyle = new ThemeFont();\r\n    }\r\n\r\n    if (global === true || global === undefined) {\r\n        GOWN.theme = this;\r\n    }\r\n    this.textureCache = null;\r\n    // own skin for scroll/slider track\r\n    // (uses the default button skin otherwise)\r\n    this.thumbSkin = true;\r\n\r\n    // desktop themes have a hover skin if the mouse moves over the button\r\n    this.hoverSkin = true;\r\n}\r\n\r\nTheme.prototype = Object.create( EventEmitter.prototype );\r\nTheme.prototype.constructor = Theme;\r\nmodule.exports = Theme;\r\n\r\n// skin has changed\r\nTheme.SKIN_CHANGED = 'skin_changed';\r\n\r\n// theme texture loaded\r\nTheme.LOADED = 'loaded';\r\n\r\n// theme texture has been loaded and all controls have an assigned skin\r\nTheme.COMPLETE = 'complete';\r\n\r\n/**\r\n * Set skin for ui component\r\n *\r\n * @method setSkin\r\n * @param comp ui-component that we want to skin, e.g. \"button\" {String}\r\n * @param id id for the skin (e.g. state when the skinning function will be applied {String}\r\n * @param skin skin-function that will executed once the component gets updated  {String}\r\n */\r\nTheme.prototype.setSkin = function(comp, id, skin) {\r\n    this._skins[comp] = this._skins[comp] || {};\r\n    this._skins[comp][id] = skin;\r\n    this.emit(Theme.SKIN_CHANGED, comp, this);\r\n};\r\n\r\n/**\r\n * Set up the asset loader and load files\r\n *\r\n * @method loadImage\r\n * @param jsonPath {Array}\r\n */\r\nTheme.prototype.loadImage = function(jsonPath) {\r\n    this._jsonPath = jsonPath;\r\n    GOWN.loader\r\n        .add(jsonPath)\r\n        .load(this.loadComplete.bind(this));\r\n};\r\n\r\n/**\r\n * executed when loadImage has finished\r\n *\r\n * @method loadComplete\r\n */\r\nTheme.prototype.loadComplete = function(loader, resources) {\r\n    this.setCache(resources);\r\n    this.emit(Theme.LOADED, this);\r\n    this.applyTheme();\r\n};\r\n\r\n\r\n/**\r\n * set texture cache (normally called when loading is complete)\r\n *\r\n * @method loadComplete\r\n */\r\nTheme.prototype.setCache = function(resources) {\r\n    this.textureCache = resources[this._jsonPath].textures;\r\n};\r\n\r\n\r\n/**\r\n * apply theme to controls\r\n * (normally executed only once after the texture has been loaded)\r\n *\r\n * @method applyTheme\r\n */\r\nTheme.prototype.applyTheme = function() {\r\n    this.emit(Theme.COMPLETE, this);\r\n};\r\n\r\n/**\r\n * Create new Scalable Container\r\n *\r\n * @method getScaleContainer\r\n * @param name id defined in the asset loader {String}\r\n * @param grid grid defining the inner square of the scalable container {Rectangle}\r\n * @returns {Function}\r\n */\r\nTheme.prototype.getScaleContainer = function(name, grid, middleWidth, centerHeight) {\r\n    var scope = this;\r\n    return function() {\r\n        var texture = scope.textureCache[name];\r\n        if(!texture) {\r\n            throw new Error('The frameId \"' + name + '\" does not exist ' +\r\n            'in the texture cache');\r\n        }\r\n        return new ScaleContainer(texture, grid, middleWidth, centerHeight);\r\n\r\n    };\r\n};\r\n\r\n/**\r\n * Create new Sprite from image name\r\n *\r\n * @method getImage\r\n * @param name id defined in the asset loader {String}\r\n * @returns {Function}\r\n */\r\nTheme.prototype.getImage = function(name) {\r\n    var scope = this;\r\n    return function() {\r\n        return new PIXI.Sprite(scope.textureCache[name]);\r\n    };\r\n};\r\n\r\n/**\r\n * Get skin by component and state (or type)\r\n *\r\n * @method getSkin\r\n * @param comp name of the component (e.g. button) {String}\r\n * @param state (state or type of the skin e.g. \"up\") {String}\r\n * @returns {DisplayObject}\r\n */\r\nTheme.prototype.getSkin = function(comp, state) {\r\n    if (this._skins[comp] && this._skins[comp][state]) {\r\n        return this._skins[comp][state]();\r\n    }\r\n    return null;\r\n};\r\n\r\n/**\r\n * Shortcut to remove the theme from global context\r\n *\r\n * @method removeTheme\r\n */\r\nTheme.removeTheme = function() {\r\n    GOWN.theme = undefined;\r\n};\r\n","var OPTIONS = ['fontSize', 'fontFamily', 'fill', 'align', 'stroke',\r\n               'strokeThickness', 'wordWrap', 'wordWrapWidth', 'lineHeight',\r\n               'dropShadow', 'dropShadowColor', 'dropShadowAngle',\r\n               'dropShadowDistance', 'padding', 'textBaseline',\r\n               'lineJoin', 'miterLimit'];\r\n\r\n/**\r\n * @class ThemeFont\r\n * @memberof GOWN\r\n * @constructor\r\n */\r\nfunction ThemeFont(data) {\r\n    for(var key in data) {\r\n        if(OPTIONS.indexOf(key) !== -1) {\r\n            this[key] = data[key];\r\n        }\r\n    }\r\n\r\n    this.fill = this.fill || '#000';\r\n    // default font for label (e.g. buttons)\r\n    this._fontFamily = this._fontFamily || 'Arial';\r\n    this._fontSize = this._fontSize || 12;\r\n}\r\n\r\nmodule.exports = ThemeFont;\r\n\r\n\r\n/**\r\n * clone ThemeFont instance\r\n *\r\n * @method clone\r\n */\r\nThemeFont.prototype.clone = function() {\r\n    var re = new ThemeFont();\r\n    for(var key in this) {\r\n        if(OPTIONS.indexOf(key) !== -1) {\r\n            re[key] = this[key];\r\n        }\r\n    }\r\n    return re;\r\n};\r\n\r\n/**\r\n * update font string\r\n *\r\n * @method _updateFont\r\n * @private\r\n */\r\nThemeFont.prototype._updateFont = function() {\r\n    this._font = this._fontSize + 'px ' + this._fontFamily;\r\n};\r\n\r\n/**\r\n * instead of setting font using fontFamily and fontSize is encouraged\r\n *\r\n * @property font\r\n * @type String\r\n */\r\nObject.defineProperty(ThemeFont.prototype, 'font', {\r\n    get: function() {\r\n        return this._font;\r\n    }\r\n});\r\n\r\n\r\n/**\r\n * Font Size\r\n *\r\n * @property fontSize\r\n * @type Number\r\n */\r\nObject.defineProperty(ThemeFont.prototype, 'fontSize', {\r\n    get: function() {\r\n        return this._fontSize;\r\n    },\r\n    set: function(value) {\r\n        this._fontSize = value;\r\n        this._updateFont();\r\n    }\r\n});\r\n\r\n\r\n/**\r\n * Font Familiy\r\n *\r\n * @property fontFamily\r\n * @type String\r\n */\r\nObject.defineProperty(ThemeFont.prototype, 'fontFamily', {\r\n    get: function() {\r\n        return this._fontFamily;\r\n    },\r\n    set: function(value) {\r\n        this._fontFamily = value;\r\n        this._updateFont();\r\n    }\r\n});\r\n","var Theme = require('./Theme'),\r\n    Button = require('../controls/Button'),\r\n    ToggleButton = require('../controls/ToggleButton'),\r\n\tScrollBar = require('../controls/ScrollBar'),\r\n\tScrollThumb = require('../controls/ScrollThumb'),\r\n\tCheck = require('../controls/Check');\r\n\r\n/**\r\n * load theme from .json file.\r\n *\r\n * @class Theme\r\n * @memberof GOWN\r\n * @constructor\r\n */\r\nfunction ThemeParser(jsonPath, global) {\r\n    Theme.call(this, global);\r\n\r\n    // components that show something and can be used as skin (see PIXI.shapes)\r\n    this.skinComponents = this.skinComponents || this.getSkinComponents();\r\n\r\n    this.loadThemeData(jsonPath);\r\n}\r\n\r\nThemeParser.prototype = Object.create( Theme.prototype );\r\nThemeParser.prototype.constructor = ThemeParser;\r\nmodule.exports = ThemeParser;\r\n\r\n// load theme data\r\nThemeParser.DATA_LOADED = 'data_loaded';\r\n\r\n/**\r\n * get component classes that can create skins (in general all PIXI.shapes)\r\n * note that image textures are not components\r\n */\r\nThemeParser.prototype.getSkinComponents = function () {\r\n    var cmps = {};\r\n    if (PIXI.shapes) {\r\n        cmps.rect = PIXI.shapes.Rect;\r\n        cmps.diamond = PIXI.shapes.Diamond;\r\n        cmps.ellipse = PIXI.shapes.Ellipse;\r\n        cmps.line = PIXI.shapes.Line;\r\n    }\r\n    return cmps;\r\n};\r\n\r\nThemeParser.components = {};\r\nThemeParser.components[Button.SKIN_NAME] = Button.stateNames;\r\nThemeParser.components[ToggleButton.SKIN_NAME] = ToggleButton.stateNames;\r\nThemeParser.components[Check.SKIN_NAME] = ToggleButton.stateNames;\r\nThemeParser.components[ScrollBar.SKIN_NAME] = [\r\n\t'horizontal_track', 'vertical_track'\r\n];\r\nThemeParser.components[ScrollThumb.SKIN_NAME] = ScrollThumb.THUMB_STATES;\r\n\r\nThemeParser.prototype.loadComplete = function(loader, resources) {\r\n    this.setCache(resources);\r\n\r\n    if (resources) {\r\n        var res = resources[this._jsonPath];\r\n        if (res) {\r\n            this.themeData = res.data;\r\n        }\r\n\r\n        this.applyTheme();\r\n        Theme.prototype.loadComplete.call(this, loader, resources);\r\n    }\r\n};\r\n\r\nThemeParser.prototype.themeApplyTheme = Theme.prototype.applyTheme;\r\nThemeParser.prototype.applyTheme = function() {\r\n    if (!this.themeData) {\r\n        return;\r\n    }\r\n    this.parseData(this.themeData);\r\n    this.themeApplyTheme();\r\n};\r\n\r\n/**\r\n * get scale9 grid data from theme data\r\n */\r\nThemeParser.prototype.getScale9 = function(scale) {\r\n    return new PIXI.Rectangle(\r\n        parseInt(scale[0])*this.themeScale, parseInt(scale[1])*this.themeScale,\r\n        parseInt(scale[2])*this.themeScale, parseInt(scale[3])*this.themeScale);\r\n};\r\n\r\n/**\r\n * create new skin from theme data\r\n * @param data {String}\r\n * @returns {function}\r\n */\r\nThemeParser.prototype.skinFromData = function(skinData, data) {\r\n    if (skinData.type === 'texture') {\r\n        var scale9;\r\n        if (skinData.scale9 in data.grids) {\r\n            scale9 = this.getScale9(data.grids[skinData.scale9]);\r\n        } else {\r\n            return this.getImage(skinData.texture);\r\n        }\r\n        if (!(skinData.texture in data.frames) && window.console) {\r\n            window.console.error('texture not found in texture atlas: ' +\r\n                skinData.texture + ' ' +\r\n                'please check ' + this._jsonPath);\r\n            return null;\r\n        }\r\n\r\n        return this.getScaleContainer(skinData.texture, scale9, skinData.middleWidth, skinData.centerHeight);\r\n    } else if (skinData.type in this.skinComponents) {\r\n        // keep component in scope\r\n        var CmpClass = this.skinComponents[skinData.type];\r\n        return function() {\r\n            var cmp = new CmpClass();\r\n            for (var key in skinData) {\r\n                if (key === 'type') {\r\n                    continue;\r\n                }\r\n                cmp[key] = skinData[key];\r\n            }\r\n            return cmp;\r\n        };\r\n    }\r\n};\r\n\r\n/**\r\n * create dictionary containing skin data (including default values)\r\n * @param stateName name of current state (e.g. GOWN.Button.UP) {String}\r\n * @param skinData data gathered from previous runs {String}\r\n * @param data new data that will be copied into skinData {Object}\r\n */\r\nThemeParser.prototype.getSkinData = function(stateName, skinData, data) {\r\n    if (!data) {\r\n        return;\r\n    }\r\n\r\n    var copyInto = function(source, target) {\r\n        if (!source) {\r\n            return;\r\n        }\r\n        for (var key in source) {\r\n            target[key] = source[key];\r\n        }\r\n    };\r\n\r\n    // get default skin for all states...\r\n    copyInto(data.all, skinData);\r\n\r\n    // ... override default values for current state\r\n    copyInto(data[stateName], skinData);\r\n};\r\n\r\nThemeParser.prototype.parseData = function(data) {\r\n    this.hoverSkin = data.hoverSkin;\r\n    this.thumbSkin = data.thumbSkin;\r\n    this.themeScale = data.themeScale || 1.0;\r\n\r\n    if (data.textStyle) {\r\n        this.textStyle.fill = data.textStyle.fill;\r\n        this.textStyle.fontFamily = data.textStyle.fontFamily;\r\n    }\r\n    if (!data.skins) {\r\n        return;\r\n    }\r\n\r\n    for (var componentName in ThemeParser.components) {\r\n        // create skin for componentName (e.g. button) from data\r\n\r\n        var states = ThemeParser.components[componentName];\r\n        //var skins = data.skins[componentName];\r\n        for (var i = 0; i < states.length; i++) {\r\n            var stateName = states[i];\r\n            var skinData = {};\r\n            // set defaults\r\n            this.getSkinData(stateName, skinData, data.skins.default);\r\n\r\n            // override defaults with component data\r\n            if (componentName in data.skins) {\r\n                this.getSkinData(stateName, skinData, data.skins[componentName]);\r\n            }\r\n\r\n            // create skin from skinData for current skin\r\n            var skin = this.skinFromData(skinData, data);\r\n            if (skin) {\r\n                this.setSkin(componentName, stateName, skin);\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nThemeParser.prototype.loadThemeData = function(jsonPath) {\r\n    this.loadImage(jsonPath);\r\n};\r\n","/**\r\n * Wrapper for DOM Text Input\r\n *\r\n * based on PIXI.Input InputObject by Sebastian Nette,\r\n * see https://github.com/SebastianNette/PIXI.Input\r\n *\r\n * @class InputWrapper\r\n * @memberof GOWN\r\n * @static\r\n */\r\nfunction InputWrapper() {\r\n}\r\n\r\nmodule.exports = InputWrapper;\r\n\r\n/**\r\n * DOM input field.\r\n * we use one input field for all InputControls\r\n *\r\n * @property hiddenInput\r\n * @type DOMObject\r\n * @static\r\n */\r\nInputWrapper.hiddenInput = null;\r\n\r\n/**\r\n * create/return unique input field.\r\n * @returns {DOMObject}\r\n */\r\nInputWrapper.createInput = function() {\r\n    if (!InputWrapper.hiddenInput) {\r\n        var input = document.createElement('input');\r\n        input.type = 'text';\r\n        input.tabindex = -1;\r\n        input.style.position = 'fixed';\r\n        input.style.opacity = 0;\r\n        input.style.pointerEvents = 'none';\r\n        input.style.left = '0px';\r\n        input.style.bottom = '0px';\r\n        input.style.left = '-100px';\r\n        input.style.top = '-100px';\r\n        input.style.zIndex = 10;\r\n\r\n        // add blur handler\r\n        input.addEventListener('blur', function()\r\n        {\r\n            if (GOWN.InputControl.currentInput)\r\n            {\r\n                GOWN.InputControl.currentInput.onMouseUpOutside();\r\n            }\r\n        }, false);\r\n\r\n        // on key down\r\n        input.addEventListener('keydown', function(e)\r\n        {\r\n            if (GOWN.InputControl.currentInput)\r\n            {\r\n                e = e || window.event;\r\n                if (GOWN.InputControl.currentInput.hasFocus)\r\n                {\r\n                    GOWN.InputControl.currentInput.onKeyDown();\r\n                    var keyCode = e.which;\r\n\r\n                    // ESC\r\n                    if (keyCode === 27) {\r\n                        GOWN.InputControl.currentInput.blur();\r\n                        return;\r\n                    }\r\n\r\n                    // add support for Ctrl/Cmd+A selection - select whole input text\r\n                    if (keyCode === 65 && (e.ctrlKey || e.metaKey)) {\r\n                        e.preventDefault();\r\n                        GOWN.InputControl.currentInput.updateSelection(\r\n                            0, GOWN.InputControl.currentInput.text.length);\r\n                        return;\r\n                    }\r\n\r\n                    // block keys that shouldn't be processed\r\n                    if (keyCode === 17 || e.metaKey || e.ctrlKey) {\r\n                        return;\r\n                    }\r\n\r\n                    // enter key\r\n                    if (keyCode === 13) {\r\n                        e.preventDefault();\r\n                        GOWN.InputControl.currentInput.onEnter();\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        // on key up\r\n        input.addEventListener('keyup', function(e)\r\n        {\r\n            if(GOWN.InputControl.currentInput)\r\n            {\r\n                e = e || window.event;\r\n                if (GOWN.InputControl.currentInput.hasFocus)\r\n                {\r\n                    GOWN.InputControl.currentInput.onKeyUp();\r\n                }\r\n            }\r\n        });\r\n\r\n        document.body.appendChild(input);\r\n\r\n        InputWrapper.hiddenInput = input;\r\n    }\r\n    return InputWrapper.hiddenInput;\r\n};\r\n\r\n/**\r\n * key to get text ('value' for default input field)\r\n * @type {string}\r\n * @static\r\n * @private\r\n */\r\nInputWrapper.textProp = 'value';\r\n\r\n/**\r\n * activate the text input\r\n */\r\nInputWrapper.focus = function()\r\n{\r\n    if (InputWrapper.hiddenInput) {\r\n        InputWrapper.hiddenInput.focus();\r\n    }\r\n};\r\n\r\n/**\r\n * deactivate the text input\r\n */\r\nInputWrapper.blur = function()\r\n{\r\n    if (InputWrapper.hiddenInput) {\r\n        InputWrapper.hiddenInput.blur();\r\n    }\r\n};\r\n\r\n\r\n/**\r\n * set selection\r\n * @returns {DOMObject}\r\n */\r\nInputWrapper.setSelection = function(start, end)\r\n{\r\n    if (InputWrapper.hiddenInput) {\r\n        InputWrapper.hiddenInput.selectionStart = start;\r\n        InputWrapper.hiddenInput.selectionEnd = end;\r\n    } else {\r\n        InputWrapper._selection = [start, end];\r\n    }\r\n};\r\n\r\n/**\r\n * get start and end of selection\r\n * @returns {Array}\r\n */\r\nInputWrapper.getSelection = function() {\r\n    if (InputWrapper.hiddenInput) {\r\n        return [\r\n            InputWrapper.hiddenInput.selectionStart,\r\n            InputWrapper.hiddenInput.selectionEnd\r\n        ];\r\n    } else {\r\n        return InputWrapper._selection;\r\n    }\r\n};\r\n\r\n/**\r\n * get text value from hiddenInput\r\n * @returns {String}\r\n */\r\nInputWrapper.getText = function() {\r\n    if (InputWrapper.hiddenInput) {\r\n        var textProp = InputWrapper.textProp;\r\n        var txt = InputWrapper.hiddenInput[textProp];\r\n        return txt.replace(/\\r/g, '');\r\n    } else {\r\n        return InputWrapper._text;\r\n    }\r\n\r\n};\r\n\r\n/**\r\n * get text value to hiddenInput\r\n * @param {String} text\r\n */\r\nInputWrapper.setText = function(text) {\r\n    if (InputWrapper.hiddenInput) {\r\n        var textProp = InputWrapper.textProp;\r\n        InputWrapper.hiddenInput[textProp] = text;\r\n    } else {\r\n        InputWrapper._text = text;\r\n    }\r\n};\r\n\r\n/**\r\n * set max. length setting it to 0 will allow unlimited text input\r\n * @param length\r\n */\r\nInputWrapper.setMaxLength = function(length) {\r\n    if (InputWrapper.hiddenInput) {\r\n        if (!length || length < 0) {\r\n            InputWrapper.hiddenInput.removeAttribute('maxlength');\r\n        } else {\r\n            InputWrapper.hiddenInput.setAttribute('maxlength', length);\r\n        }\r\n    } else {\r\n        InputWrapper._maxLength = length;\r\n    }\r\n};\r\n\r\nInputWrapper.setType = function(type) {\r\n    if (InputWrapper.hiddenInput) {\r\n        InputWrapper.hiddenInput.type = type;\r\n    } else {\r\n        InputWrapper._type = type;\r\n    }\r\n};\r\n\r\nInputWrapper.getType = function() {\r\n    if (InputWrapper.hiddenInput) {\r\n        return InputWrapper.hiddenInput.type;\r\n    } else {\r\n        return InputWrapper._type;\r\n    }\r\n};\r\n","/**\n * Scale 9 Container.\n * e.g. useful for scalable buttons.\n *\n * @class ScaleContainer\n * @extends PIXI.Container\n * @memberof GOWN\n * @constructor\n * @param texture {Texture}\n * @param rect rectangle with position and dimensions of the center piece. Will be used to calculate positons of all other pieces {PIXI.Rectangle}\n * @middleWidth (optional) alternative width to crop the center piece (only needed if we want to scale the image smaller than the original)\n * @centerHeight (optional) alternative height to crop the center piece (only needed if we want to scale the image smaller than the original)\n */\n\nfunction ScaleContainer(texture, rect, middleWidth, centerHeight) {\n    PIXI.Container.call( this );\n\n    this.rect = rect;\n    this.baseTexture = texture.baseTexture;\n    this.frame = texture.frame;\n\n    this._width = this.frame.width;\n    this._height = this.frame.height;\n\n    // left / middle / right width\n    var lw = rect.x;\n    var mw = rect.width;\n    var rw = this.frame.width - (mw + lw);\n\n    // top / center / bottom height\n    var th = rect.y;\n    var ch = rect.height;\n    var bh = this.frame.height - (ch + th);\n\n    middleWidth = middleWidth || mw;\n    centerHeight = centerHeight || ch;\n\n    /**\n     * calculated min. width based on tile sizes in pixel without scaling\n     * (if middleWidth is not set it is the same as the width of the\n     *  texture in the atlas)\n     */\n    this.minWidth = lw + middleWidth + rw;\n\n    /**\n     * calculated min. height based on tile sizes in pixel without scaling\n     * (if middleWidth is not set it is the same as the height of the\n     *  texture in the atlas)\n     */\n    this.minHeight = th + centerHeight + bh;\n\n    // top left\n    if (lw > 0 && th > 0) {\n        this.tl = this._getTexture(0, 0, lw, th);\n        this.addChild(this.tl);\n    }\n    // top middle\n    if (mw > 0 && th > 0) {\n        this.tm = this._getTexture(lw, 0, middleWidth, th);\n        this.addChild(this.tm);\n        this.tm.x = lw;\n    }\n    // top right\n    if (rw > 0 && th > 0) {\n        this.tr = this._getTexture(lw + mw, 0, rw, th);\n        this.addChild(this.tr);\n    }\n\n    // center left\n    if (lw > 0 && ch > 0) {\n        this.cl = this._getTexture(0, th, lw, centerHeight);\n        this.addChild(this.cl);\n        this.cl.y = th;\n    }\n    // center middle\n    if (mw > 0 && ch > 0) {\n        this.cm = this._getTexture(lw, th, middleWidth, centerHeight);\n        this.addChild(this.cm);\n        this.cm.y = th;\n        this.cm.x = lw;\n    }\n    // center right\n    if (rw > 0 && ch > 0) {\n        this.cr = this._getTexture(lw + mw, th, rw, centerHeight);\n        this.addChild(this.cr);\n        this.cr.y = th;\n    }\n\n    // bottom left\n    if (lw > 0 && bh > 0) {\n        this.bl = this._getTexture(0, th + ch, lw, bh);\n        this.addChild(this.bl);\n    }\n    // bottom middle\n    if (mw > 0 && bh > 0) {\n        this.bm = this._getTexture(lw, th + ch, middleWidth, bh);\n        this.addChild(this.bm);\n        this.bm.x = lw;\n    }\n    // bottom right\n    if (rw > 0 && bh > 0) {\n        this.br = this._getTexture(lw + mw, th + ch, rw, bh);\n        this.addChild(this.br);\n    }\n}\n\n// constructor\nScaleContainer.prototype = Object.create( PIXI.Container.prototype );\nScaleContainer.prototype.constructor = ScaleContainer;\nmodule.exports = ScaleContainer;\n\n/**\n * set scaling width and height\n *\n * @method _updateScales\n * @private\n */\nScaleContainer.prototype._updateScales = function() {\n    this._positionTilable();\n\n    var scaleOriginals = this.scaleOriginals = {};\n\n    var scaleOriginal = function(name, elem) {\n        if (elem && elem.width && elem.height) {\n            scaleOriginals[name] = {\n                width: elem.width,\n                height: elem.height\n            };\n        }\n    };\n\n    scaleOriginal('tl', this.tl);\n    scaleOriginal('tm', this.tm);\n    scaleOriginal('tr', this.tr);\n\n    scaleOriginal('cl', this.cl);\n    scaleOriginal('cm', this.cm);\n    scaleOriginal('cr', this.cr);\n\n    scaleOriginal('bl', this.bl);\n    scaleOriginal('bm', this.bm);\n    scaleOriginal('br', this.br);\n};\n\n/**\n * create a new texture from a base-texture by given dimensions\n *\n * @method _getTexture\n * @private\n */\nScaleContainer.prototype._getTexture = function(x, y, w, h) {\n    var frame = new PIXI.Rectangle(this.frame.x+x, this.frame.y+y, w, h);\n    var t = new PIXI.Texture(this.baseTexture, frame, frame.clone(), null);\n    return new PIXI.Sprite(t);\n};\n\n/**\n * The width of the container, setting this will redraw the component.\n *\n * @property width\n * @type Number\n */\nObject.defineProperty(ScaleContainer.prototype, 'width', {\n    get: function() {\n        return this._width;\n    },\n    set: function(value) {\n        if (this._width !== value) {\n            if (this.minWidth && this.minWidth > 0 &&\n                value < this.minWidth) {\n                value = this.minWidth;\n            }\n            this._width = value;\n            this.invalid = true;\n            this._updateScales();\n        }\n    }\n});\n\n/**\n * The height of the container, setting this will redraw the component.\n *\n * @property height\n * @type Number\n */\nObject.defineProperty(ScaleContainer.prototype, 'height', {\n    get: function() {\n        return this._height;\n    },\n    set: function(value) {\n        if (this._height !== value) {\n            if (this.minHeight && this.minHeight > 0 &&\n                value < this.minHeight) {\n                value = this.minHeight;\n            }\n            this._height = value;\n            this.invalid = true;\n            this._updateScales();\n        }\n    }\n});\n\n/**\n * update before draw call (reposition textures)\n *\n * @method redraw\n */\nScaleContainer.prototype.redraw = function() {\n    if (this.invalid) {\n        this._positionTilable();\n        this.invalid = false;\n    }\n};\n\n/**\n * recalculate the position of the tiles (every time width/height changes)\n *\n * @method _positionTilable\n * @private\n */\nScaleContainer.prototype._positionTilable = function() {\n    // left / middle / right width\n    var lw = this.rect.x;\n    var mw = this.rect.width;\n    var rw = this.frame.width - (mw + lw);\n\n    // top / center / bottom height\n    var th = this.rect.y;\n    var ch = this.rect.height;\n    var bh = this.frame.height - (ch + th);\n\n    var rightX = this._width - rw;\n    var bottomY = this._height - bh;\n    if (this.cr) {\n        this.cr.x = rightX;\n    }\n    if (this.br) {\n        this.br.x = rightX;\n        this.br.y = bottomY;\n    }\n    if (this.tr) {\n        this.tr.x = rightX;\n    }\n\n    var middleWidth = this._width - (lw + rw);\n    var centerHeight = this._height - (th + bh);\n    if (this.cm) {\n        this.cm.width = middleWidth;\n        this.cm.height = centerHeight;\n    }\n    if (this.bm) {\n        this.bm.width = middleWidth;\n        this.bm.y = bottomY;\n    }\n    if (this.tm) {\n        this.tm.width = middleWidth;\n    }\n    if (this.cl) {\n        this.cl.height = centerHeight;\n    }\n    if (this.cr) {\n        this.cr.height = centerHeight;\n    }\n\n    if (this.bl) {\n        this.bl.y = bottomY;\n    }\n};\n\n/**\n *\n * Helper function that creates a sprite that will contain a texture from\n * the TextureCache based on the frameId\n * The frame ids are created when a Texture packer file has been loaded\n *\n * @method fromFrame\n * @static\n * @param frameId {String} The frame Id of the texture in the cache\n * @param rect {Rectangle} defines tilable area\n * @return {ScaleTexture} A new Scalable Texture (e.g. a button) using\n *                        a texture from the texture cache matching the frameId\n */\nScaleContainer.fromFrame = function(frameId, rect) {\n    var texture = PIXI.utils.TextureCache[frameId];\n    if(!texture) {\n        throw new Error('The frameId \"' + frameId + '\" does not exist ' +\n                        'in the texture cache');\n    }\n    return new ScaleContainer(texture, rect);\n};\n","/**\r\n * Holds all information related to a Slider change event\r\n *\r\n * @class SliderData\r\n * @memberof GOWN\r\n * @constructor\r\n */\r\nfunction SliderData()\r\n{\r\n    this.value = 0;\r\n    /**\r\n     * The target Sprite that was interacted with\r\n     *\r\n     * @property target\r\n     * @type Sprite\r\n     */\r\n    this.target = null;\r\n}\r\n\r\nmodule.exports = SliderData;\r\n","/**\r\n * @file        Main export of the gown.js util library\r\n * @author      Andreas Bresser <andreasbresser@gmail.com>\r\n * @copyright   2015 Andreas Bresser\r\n * @license     {@link https://github.com/brean/gown.js/blob/master/LICENSE|Apache License}\r\n */\r\n\r\n/**\r\n * @namespace GOWN.util\r\n */\r\nmodule.exports = {\r\n    InputWrapper:           require('./InputWrapper'),\r\n    mouseWheelSupport:      require('./mouseWheelSupport'),\r\n    position:               require('./position'),\r\n    ScaleContainer:         require('./ScaleContainer'),\r\n    SliderData:             require('./SliderData'),\r\n    resizeScaling:          require('./resizeScaling'),\r\n    mixin:                  require('./mixin')\r\n};\r\n","module.exports = function(destination, source) {\r\n    for (var key in source) {\r\n        if (source.hasOwnProperty(key)) {\r\n            if(key === 'defineProperty') {\r\n                for (var name in source[key]) {\r\n                    var data = source[key][name];\r\n                    if (data.configurable === undefined) {\r\n                         // We change our default case, so that we can\r\n                         // overwrite properties later on\r\n                        data.configurable = true;\r\n                    }\r\n                    Object.defineProperty(destination, name, data);\r\n                }\r\n            } else {\r\n                destination[key] = source[key];\r\n            }\r\n        }\r\n    }\r\n    return destination;\r\n};\r\n","/**\r\n * TODO: make it work with PIXI (this is just copied from createjs_ui / WIP)\r\n * (e.g. get currently selected object using this.stage.interactionManager.hitTest(this, e)\r\n * and then execute an \"onwheel\"-callback)\r\n *\r\n * enable or disable mouse wheel support for canvas (e.g. for scroller)\r\n * using HTML 5 scrolling. will do nothing if it is already activated/\r\n * deactivated\r\n * based on http://www.sitepoint.com/html5-javascript-mouse-wheel/\r\n * @param stage the PIXI-stage\r\n * @param enable true to enable mouse support, false to disable,\r\n */\r\nfunction mouseWheelSupport(stage, enable) {\r\n    var canvas = stage.canvas;\r\n    if (enable || enable === undefined) {\r\n        if (GOWN._mouseWheelHandler !== undefined) {\r\n            return;\r\n        }\r\n        GOWN._mouseWheelHandler = function(event) {\r\n            event = window.event || event;\r\n            var delta = Math.max(-1, Math.min(1,\r\n                (event.wheelDelta || -event.detail)));\r\n\r\n            var target = stage.getObjectsUnderPoint(stage.mouseX, stage.mouseY, 1);\r\n            if (!target) {\r\n                return;\r\n            }\r\n            for(var i = 0; i < target.length; i++) {\r\n                var t = target[i];\r\n                t.mouseMove(delta);\r\n                /*\r\n                var evt = new createjs.MouseEvent(\r\n                    \"mousewheel\", true, false,\r\n                    t.x, t.y, event, -1, true, t.rawX, t.rawY);\r\n                evt.delta = delta;\r\n                t.dispatchEvent(evt);\r\n                */\r\n            }\r\n        };\r\n        if (canvas.addEventListener) {\r\n            canvas.addEventListener('mousewheel',\r\n                GOWN._mouseWheelHandler, false);\r\n            canvas.addEventListener('DOMMouseScroll',\r\n                GOWN._mouseWheelHandler, false);\r\n        } else {\r\n            canvas.attachEvent('onmousewheel',\r\n                GOWN._mouseWheelHandler);\r\n        }\r\n    } else {\r\n        if (GOWN._mouseWheelHandler === undefined) {\r\n            return;\r\n        }\r\n        if (canvas.removeEventListener) {\r\n            canvas.removeEventListener('mousewheel',\r\n                GOWN._mouseWheelHandler);\r\n            canvas.removeEventListener('DOMMouseScroll',\r\n                GOWN._mouseWheelHandler);\r\n        } else {\r\n            canvas.detachEvent('onmousewheel',\r\n                GOWN._mouseWheelHandler);\r\n        }\r\n        GOWN._mouseWheelHandler = undefined;\r\n    }\r\n}\r\n\r\nmodule.exports = mouseWheelSupport;","/**\r\n * center element on parent vertically\r\n * @param elem\r\n * @param parent (optional)\r\n * @method centerVertical\r\n */\r\nfunction centerVertical(elem, parent) {\r\n    parent = parent || elem.parent;\r\n    elem.y = Math.floor((parent.height - elem.height ) / 2);\r\n}\r\n\r\n/**\r\n *\r\n * @param elem\r\n * @param parent (optional)\r\n */\r\nfunction bottom(elem, parent) {\r\n    parent = parent || elem.parent;\r\n    elem.y = parent.height - elem.height;\r\n}\r\n\r\n/**\r\n * center element on parent horizontally\r\n * @param elem\r\n * @param parent (optional)\r\n * @method centerHorizontal\r\n */\r\nfunction centerHorizontal(elem, parent) {\r\n    parent = parent || elem.parent;\r\n    elem.x = Math.floor((parent.width - elem.width ) / 2);\r\n}\r\n\r\n\r\n/**\r\n * center element on parent\r\n * @param elem\r\n * @param parent (optional)\r\n * @method center\r\n */\r\nfunction center(elem, parent) {\r\n    centerVertical(elem, parent);\r\n    centerHorizontal(elem, parent);\r\n}\r\n\r\n\r\nmodule.exports = {\r\n    centerHorizontal: centerHorizontal,\r\n    centerVertical: centerVertical,\r\n    center: center,\r\n    bottom: bottom\r\n};\r\n","\r\nmodule.exports = {\r\n    /**\r\n     * this should be called from inside the constructor\r\n     *\r\n     * @method initResizeScaling\r\n     */\r\n    initResizeScaling: function() {\r\n        this.resizeScaling = true; // resize instead of scale\r\n\r\n        this.minWidth = 1;\r\n        this.minHeight = 1;\r\n\r\n        // update dimension flag\r\n        this._lastWidth = NaN;\r\n        this._lastHeight = NaN;\r\n    },\r\n\r\n    /**\r\n     * update before draw call\r\n     * redraw control for current state from theme\r\n     *\r\n     * @method redraw\r\n     */\r\n    redraw: function() {\r\n        // remove last skin after new one has been added\r\n        // (just before rendering, otherwise we would see nothing for a frame)\r\n        if (this._lastSkin) {\r\n            //this.removeChild(this._lastSkin);\r\n            this._lastSkin.alpha = 0;\r\n            this._lastSkin = null;\r\n        }\r\n        if (this.invalidState) {\r\n            this.fromSkin(this._currentState, this.changeSkin);\r\n        }\r\n        var width = this.worldWidth;\r\n        var height = this.worldHeight;\r\n        if (this._currentSkin &&\r\n            (this._lastWidth !== width || this._lastHeight !== height) &&\r\n            width > 0 && height > 0) {\r\n\r\n            this._currentSkin.width = this._lastWidth = width;\r\n            this._currentSkin.height = this._lastHeight = height;\r\n            this.updateDimensions();\r\n        }\r\n    },\r\n\r\n    updateDimensions: function() {\r\n    },\r\n\r\n\r\n    updateTransform: function() {\r\n        var wt = this.worldTransform;\r\n        var scaleX = 1;\r\n        var scaleY = 1;\r\n\r\n        if(this.redraw) {\r\n\r\n            if(this.resizeScaling) {\r\n                var pt = this.parent.worldTransform;\r\n\r\n                scaleX = Math.sqrt(Math.pow(pt.a, 2) + Math.pow(pt.b, 2));\r\n                scaleY = Math.sqrt(Math.pow(pt.c, 2) + Math.pow(pt.d, 2));\r\n            }\r\n\r\n            this.worldWidth = Math.round(Math.max(this._width * scaleX, this.minWidth));\r\n            this.worldHeight = Math.round(Math.max(this._height * scaleY, this.minHeight));\r\n            this.redraw();\r\n        }\r\n\r\n        // obmit Control.updateTransform as it calls redraw as well\r\n        if(!this.resizeScaling) {\r\n            PIXI.Container.prototype.updateTransform.call(this);\r\n        } else {\r\n            PIXI.DisplayObject.prototype.updateTransform.call(this);\r\n\r\n            // revert scaling\r\n            var tx = wt.tx;\r\n            var ty = wt.ty;\r\n            scaleX = scaleX !== 0 ? 1/scaleX : 0;\r\n            scaleY = scaleY !== 0 ? 1/scaleY : 0;\r\n            wt.scale(scaleX, scaleY);\r\n            wt.tx = tx;\r\n            wt.ty = ty;\r\n\r\n            for (var i = 0, j = this.children.length; i < j; ++i) {\r\n                this.children[i].updateTransform();\r\n            }\r\n        }\r\n    },\r\n\r\n    defineProperty: {\r\n\r\n            'height': {\r\n                get: function() {\r\n                    return this._height;\r\n                },\r\n                set: function(value) {\r\n                    this._height = value;\r\n                    this.minHeight = Math.min(value, this.minHeight);\r\n                }\r\n            },\r\n            'width': {\r\n                get: function() {\r\n                    return this._width;\r\n                },\r\n                set: function(value) {\r\n                    this._width = value;\r\n                    this.minWidth = Math.min(value, this.minWidth);\r\n                }\r\n            }\r\n    }\r\n};\r\n"]}